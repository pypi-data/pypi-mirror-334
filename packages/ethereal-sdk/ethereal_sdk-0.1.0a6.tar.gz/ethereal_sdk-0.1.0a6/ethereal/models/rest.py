# generated by datamodel-codegen:
#   filename:  spec.json
#   timestamp: 2025-03-03T23:29:06+00:00

from __future__ import annotations

from decimal import Decimal
from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Field, confloat, constr

## Overrides
# - Replace all nextCursor instances with Optional[str], and an optional None value
# - Replace includeSelfTrades in the V1OrderTradeGetParametersQuery with Optional[bool]


class SubaccountDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the registered subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    name: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    account: str = Field(
        ...,
        description="Address of the account which registered the subaccount",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    blockNumber: str = Field(
        ...,
        description="Block number this subaccount was registered on",
        examples=["123062737"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp this subaccount was registered",
        examples=["1721724269"],
    )


class ListOfSubaccountDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[SubaccountDto] = Field(..., description="Array of subaccount objects")


class SubaccountBalanceDto(BaseModel):
    subaccountId: str = Field(
        ...,
        description="UUID representing the subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    tokenId: str = Field(
        ...,
        description="UUID representing the token",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    tokenAddress: str = Field(
        ...,
        description="ERC20 deposited token address (zero address if virtual)",
        examples=["0x70997970C51812dc3A010C7d01b50e0d17dc79C8"],
    )
    tokenName: str = Field(
        ...,
        description="The unique exchange defined token name driven by addToken onchain",
        examples=["ETH"],
    )
    amount: Decimal = Field(
        ...,
        description="Token balance in native units expressed as a decimal (precision: 9)",
        examples=["1.5"],
    )
    available: Decimal = Field(
        ...,
        description="Portion of balance transferrable in native units expressed as a decimal (precision: 9)",
        examples=["0.1337"],
    )
    totalUsed: Decimal = Field(
        ...,
        description="Portion of balance non-transferrable in native units expressed as a decimal (precision: 9)",
        examples=["1.3663"],
    )
    updatedAt: float = Field(
        ...,
        description="Unix timestamp the token balance was last updated",
        examples=["1721724300"],
    )


class ListOfSubaccountBalanceDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[SubaccountBalanceDto] = Field(
        ..., description="Array of order subaccount balances"
    )


class LinkSignerDtoData(BaseModel):
    subaccountId: str = Field(
        ...,
        description="UUID representing the registered subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    sender: str = Field(
        ...,
        description="Address of account that created the signature in this message",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    signer: str = Field(
        ...,
        description="Address of signer to allowed for delegated signing",
        examples=["0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"],
    )
    nonce: str = Field(
        ...,
        description="Current timestamp, with random number 0 - 1s (expressed in ns)",
        examples=["2687929537462333"],
    )


class LinkSignerDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    signerSignature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the signer"
    )
    data: LinkSignerDtoData


class SignerDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the linked signer",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    signer: str = Field(
        ...,
        description="Address of the signer linked with the subaccount",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    isActive: bool = Field(
        ...,
        description="Whether this signer is the current active signer for the subaccount",
        examples=[True],
    )
    blockNumber: Optional[str] = Field(
        None,
        description="Block number the signer has been linked on. Undefined means it has not be processed",
        examples=["123062737"],
    )
    linkedAt: Optional[float] = Field(
        None,
        description="Unix timestamp in milliseconds of when this signer was linked onchain",
        examples=["1721724269000"],
    )
    expiresAt: float = Field(
        ...,
        description="Unix timestamp in milliseconds of when this signer will expire",
        examples=["1721724269000"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp in milliseconds the signer to submitted for linkage",
        examples=["1721724269000"],
    )


class RevokeLinkedSignerDtoData(BaseModel):
    subaccountId: str = Field(
        ...,
        description="UUID representing the registered subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    sender: str = Field(
        ...,
        description="Address of account that created the signature in this message",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    signer: str = Field(
        ...,
        description="Address of signer to revoke",
        examples=["0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"],
    )
    nonce: str = Field(
        ...,
        description="Current timestamp, with random number 0 - 1s (expressed in ns)",
        examples=["2687929537462333"],
    )


class RevokeLinkedSignerDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    data: RevokeLinkedSignerDtoData


class AccountSignerQuotaDto(BaseModel):
    maxLinkedSignersPeriodDays: float = Field(
        ...,
        description="Ratelimit period in days for linking signers per account",
        examples=[7],
    )
    maxLinkedSignersInPeriod: float = Field(
        ...,
        description="Max number of signer that can be linked within ratelimit period",
        examples=[10],
    )
    linkedSignersUsedInPeriod: float = Field(
        ...,
        description="Number of signers linked within current ratelimit period",
        examples=[2],
    )
    activeSignerExpiresAt: Optional[float] = Field(
        None,
        description="Unix timestamp in milliseconds of when current active signer for the subaccount will expire",
        examples=[1721724269000],
    )


class ListOfSignersDto(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[SignerDto] = Field(..., description="Array of signer objects")


class Status(Enum):
    SUBMITTED = "SUBMITTED"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    REJECTED = "REJECTED"


class WithdrawDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the withdraw",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    initiatedBlockNumber: Optional[str] = Field(
        None,
        description="Block number the withdraw was initiated on",
        examples=["123062000"],
    )
    finalizedBlockNumber: Optional[str] = Field(
        None,
        description="Block number the withdraw was completed on",
        examples=["123062992"],
    )
    status: Status = Field(
        ..., description="Current status of the withdraw", examples=["PENDING"]
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    token: str = Field(
        ...,
        description="Address of asset withdraw",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )
    amount: str = Field(
        ...,
        description="Amount of asset transferred expressed as a decimal",
        examples=["1.5"],
    )
    isReady: bool = Field(
        ...,
        description="Indicates whether a withdraw is ready to be finalized onchain",
        examples=[True],
    )
    readyAt: Optional[confloat(ge=1.0)] = Field(
        None,
        description="Timestamp estimate when the withdraw is ready",
        examples=[1721724269],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp the withdraw was created",
        examples=[1721724269],
    )


class ListOfWithdrawDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[WithdrawDto] = Field(
        ..., description="Array of subaccount withdraw objects"
    )


class Type(Enum):
    DEPOSIT = "DEPOSIT"
    FEE_ACCRUED = "FEE_ACCRUED"
    FEES_CLAIMED = "FEES_CLAIMED"
    WITHDRAW = "WITHDRAW"


class TransferDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the transfer",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    initiatedBlockNumber: Optional[str] = Field(
        None,
        description="Block number the transfer was initiated on",
        examples=["123062000"],
    )
    finalizedBlockNumber: Optional[str] = Field(
        None,
        description="Block number the transfer was completed on",
        examples=["123062992"],
    )
    status: Status = Field(
        ..., description="Current status of the transfer", examples=["PENDING"]
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    token: str = Field(
        ...,
        description="Address of token transferred",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )
    type: Type = Field(
        ..., description="Type of transfer (WITHDRAW or DEPOSIT)", examples=["WITHDRAW"]
    )
    amount: str = Field(
        ...,
        description="Amount of tokens transferred in native units expressed as a decimal (precision: 9)",
        examples=["0.42"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp the transfer was created",
        examples=[1721724269],
    )
    initiatedTransactionHash: Optional[str] = Field(
        None,
        description="Transaction hash for the initiation of the transfer",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )
    finalizedTransactionHash: Optional[str] = Field(
        None,
        description="Transaction hash for the finalization of the transfer",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )


class ListOfTransfersDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[TransferDto] = Field(..., description="Array of transfer objects")


class InitiateWithdrawDtoData(BaseModel):
    account: str = Field(
        ...,
        description="Account address",
        examples=["0x70997970C51812dc3A010C7d01b50e0d17dc79C8"],
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    token: str = Field(
        ...,
        description="Address of token to be withdrawn",
        examples=["0x5FC8d32690cc91D4c39d9d3abcBD16989F875707"],
    )
    amount: Decimal = Field(
        ...,
        description="Amount to withdraw in native units expressed as a decimal (precision: 9)",
        examples=["1337.42"],
    )
    nonce: str = Field(
        ...,
        description="Current timestamp, with random number 0 - 1s (expressed in ns)",
        examples=["2687929537462333"],
    )


class InitiateWithdrawDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    data: InitiateWithdrawDtoData


class TokenDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the token",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    address: str = Field(
        ...,
        description="Address of the token (zero address virtual)",
        examples=["0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"],
    )
    name: str = Field(
        ...,
        description="The unique exchange defined token name driven by addToken onchain",
        examples=["ETH"],
    )
    erc20Name: Optional[str] = Field(
        None,
        description="ERC20 token name (available if not virtual)",
        examples=["Wrapped Ether"],
    )
    erc20Symbol: Optional[str] = Field(
        None,
        description="ERC20 token symbol (available if not virtual)",
        examples=["WETH"],
    )
    erc20Decimals: Optional[float] = Field(
        None,
        description="ERC20 token decimals (available if not virtual)",
        examples=[18],
    )
    depositEnabled: bool = Field(
        ..., description="Whether the token is enabled for deposit", examples=[True]
    )
    withdrawEnabled: bool = Field(
        ..., description="Whether the token is enabled for withdraw", examples=[True]
    )
    depositFee: str = Field(
        ...,
        description="Amount of native units charged on deposit expressed as a decimal (precision: 9)",
        examples=["0"],
    )
    withdrawFee: str = Field(
        ...,
        description="Amount of native units charged on withdraw expressed as a decimal (precision: 9)",
        examples=["0.0001"],
    )
    minDeposit: str = Field(
        ...,
        description="Min deposit amount as native units expressed as a decimal (precision: 9)",
        examples=["0.1"],
    )
    createdAt: float = Field(
        ..., description="Unix timestamp the token was added", examples=[1721724269]
    )


class ListOfTokenDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[TokenDto] = Field(..., description="Array of token objects")


class DomainTypeDto(BaseModel):
    name: str = Field(..., description="Name of signing domain")
    version: str = Field(..., description="Current major version of the signing domain")
    chainId: float = Field(..., description="The EIP-155 chain id")
    verifyingContract: str = Field(
        ..., description="Address of the contract that will verify the signature"
    )


class SignatureTypesDto(BaseModel):
    LinkSigner: str = Field(..., description="LinkSigner signature type")
    TradeOrder: str = Field(..., description="TradeOrder signature type")
    InitiateWithdraw: str = Field(..., description="InitiateWithdraw signature type")
    UpdateFunding: str = Field(..., description="UpdateFunding signature type")
    RevokeLinkedSigner: str = Field(
        ..., description="RevokeLinkedSigner signature type"
    )
    CancelOrder: str = Field(..., description="CancelOrder signature type")


class RpcConfigDto(BaseModel):
    domain: DomainTypeDto = Field(..., description="Domain type")
    signatureTypes: SignatureTypesDto = Field(..., description="Signature types")


class Type1(Enum):
    LIMIT = "LIMIT"
    MARKET = "MARKET"


class Side(Enum):
    BUY = 0
    SELL = 1


class Status2(Enum):
    SUBMITTED = "SUBMITTED"
    NEW = "NEW"
    FILLED_PARTIAL = "FILLED_PARTIAL"
    FILLED = "FILLED"
    CANCELED = "CANCELED"
    REJECTED = "REJECTED"


class TimeInForce(Enum):
    GTC = "GTC"
    IOC = "IOC"
    FOK = "FOK"


class OrderDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the order",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    type: Type1 = Field(
        ..., description="Trade order type e.g. MARKET or LIMIT", examples=["LIMIT"]
    )
    availableQuantity: str = Field(
        ...,
        description="Remaining quantity (if modified or reduced) in native units expressed as a decimal (precision: 9)",
        examples=["10.5"],
    )
    quantity: str = Field(
        ...,
        description="Original quantity (as per order submission) in native units expressed as a decimal (precision: 9)",
        examples=["10.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    productId: str = Field(
        ...,
        description="UUID of product this order was submitted to",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    subaccountId: str = Field(
        ...,
        description="UUID of the subaccount associated to order",
        examples=["c25c39d9-ce2b-4753-960c-c5ad558aace8"],
    )
    status: Status2 = Field(..., description="Status of the order", examples=["FILLED"])
    reduceOnly: bool = Field(
        ..., description="Indicates if the order is reduce only", examples=[True]
    )
    updatedAt: float = Field(
        ...,
        description="Unix timestamp this order was last updated",
        examples=["1721724300"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp this order was created",
        examples=["1721724269"],
    )
    sender: str = Field(
        ...,
        description="The account or linked signer address that originally submitted this order",
        examples=["0x2501c477d0a35545a387aa4a3eee4292a9a8b3f0"],
    )
    price: str = Field(
        ...,
        description="Limit price in native units expressed as a decimal, zero if market order (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Filled amount in native units expressed as a decimal (precision: 9)",
        examples=["0.5"],
    )
    timeInForce: Optional[TimeInForce] = Field(
        None,
        description="How long an order will remain until executed/expired (required if limit)",
        examples=["GTC"],
    )
    postOnly: Optional[bool] = Field(
        None,
        description="Only add order if it does not immediately fill (limit only)",
        examples=[True],
    )


class ListOfOrderDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[OrderDto] = Field(..., description="Array of order objects")


class Type2(Enum):
    MARKET = "MARKET"


class EngineType(Enum):
    PERP = 0
    SPOT = 1


class SubmitOrderMarketDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    sender: str = Field(
        ...,
        description="Address of account",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    nonce: str = Field(
        ...,
        description="Current timestamp, with random number 0 - 1s (expressed in ns)",
        examples=["2687929537462333"],
    )
    type: Type2 = Field(
        ..., description="Trade order type e.g. MARKET or LIMIT", examples=["MARKET"]
    )
    quantity: Decimal = Field(
        ...,
        description="Quantity of product in native units expressed as a decimal (precision: 9)",
        examples=["5.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    onchainId: confloat(ge=1.0) = Field(
        ...,
        description="Onchain generated productId from prior product registration",
        examples=[1],
    )
    engineType: EngineType = Field(
        ..., description="Product engine type e.g. PERP (0)", examples=[0]
    )
    reduceOnly: bool = Field(
        ..., description="Whether this should be a reduce-only order"
    )


class Type3(Enum):
    LIMIT = "LIMIT"


class SubmitOrderLimitDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    sender: str = Field(
        ...,
        description="Address of account",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    nonce: str = Field(
        ...,
        description="Current timestamp, with random number 0 - 1s (expressed in ns)",
        examples=["2687929537462333"],
    )
    type: Type3 = Field(
        ..., description="Trade order type e.g. MARKET or LIMIT", examples=["LIMIT"]
    )
    quantity: Decimal = Field(
        ...,
        description="Quantity of product in native units expressed as a decimal (precision: 9)",
        examples=["5.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    onchainId: confloat(ge=1.0) = Field(
        ...,
        description="Onchain generated productId from prior product registration",
        examples=[1],
    )
    engineType: EngineType = Field(
        ..., description="Product engine type e.g. PERP (0)", examples=[0]
    )
    reduceOnly: bool = Field(
        ..., description="Whether this should be a reduce-only order"
    )
    price: Decimal = Field(
        ...,
        description="Limit price expressed as a decimal, zero if market order (precision: 9)",
        examples=["4200.5"],
    )
    timeInForce: TimeInForce = Field(
        ...,
        description="How long an order will remain until executed/expired",
        examples=["IOC"],
    )
    postOnly: bool = Field(
        ...,
        description="Only add order if it does not immediately fill",
        examples=[True],
    )


class SubmitOrderDto(BaseModel):
    data: Union[SubmitOrderMarketDtoData, SubmitOrderLimitDtoData]
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )


class SubmitDryOrderDto(BaseModel):
    data: Union[SubmitOrderMarketDtoData, SubmitOrderLimitDtoData]


class RejectReason(Enum):
    TechnicalError = "TechnicalError"
    ImmediateMatchPostOnly = "ImmediateMatchPostOnly"
    RiskLimitExceeded = "RiskLimitExceeded"
    OrderIncreasesPosition = "OrderIncreasesPosition"
    UnfilledImmediateOrCancel = "UnfilledImmediateOrCancel"
    UnfilledFillOrKill = "UnfilledFillOrKill"
    InsufficientBalance = "InsufficientBalance"
    Liquidation = "Liquidation"
    UnfilledMarketOrder = "UnfilledMarketOrder"
    InstrumentOpenValueCapExceeded = "InstrumentOpenValueCapExceeded"
    TriggerCanceled = "TriggerCanceled"
    OcoFilled = "OcoFilled"
    UserSetTimeoutReached = "UserSetTimeoutReached"
    InstrumentExpired = "InstrumentExpired"
    Unknown = "Unknown"
    EngineBadRequest = "EngineBadRequest"
    NotFound = "NotFound"


class OrderDryRunDto(BaseModel):
    marginRequired: str = Field(
        ...,
        description="Margin required for order in USD expressed as a decimal (precision: 9)",
        examples=["1000.5"],
    )
    marginAvailable: str = Field(
        ...,
        description="Margin available excluding this order in USD expressed as a decimal (precision: 9)",
        examples=["5000.75"],
    )
    totalUsedMargin: str = Field(
        ...,
        description="Total used margin including this order in USD expressed as a decimal (precision: 9)",
        examples=["3000.25"],
    )
    riskUsed: str = Field(
        ...,
        description="Risk used including position and open orders in USD expressed as a decimal (precision: 9)",
        examples=["3000.25"],
    )
    riskAvailable: str = Field(
        ...,
        description="Risk available for the product in USD expressed as a decimal (precision: 9)",
        examples=["100000000"],
    )
    rejectReason: Optional[RejectReason] = Field(
        None,
        description="Reason for rejecting the order, undefined if accepted",
        examples=["InsufficientBalance"],
    )


class CancelOrderDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    sender: str = Field(
        ...,
        description="Address of account that created the signature in this message",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    nonce: str = Field(
        ...,
        description="Current timestamp, with random number 0 - 1s (expressed in ns)",
        examples=["2687929537462333"],
    )
    orderIds: List[str] = Field(
        ...,
        description="Ids of the orders to be canceled",
        examples=[["80569be0-afba-43f8-ac20-767d0974c6a3"]],
        max_length=256,
        min_length=1,
    )


class CancelOrderDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    data: CancelOrderDtoData


class FailureReason(Enum):
    ALREADY_CANCELED = "ALREADY_CANCELED"
    ALREADY_EXPIRED = "ALREADY_EXPIRED"
    ALREADY_CLOSED = "ALREADY_CLOSED"
    NOT_FOUND = "NOT_FOUND"


class CancelOrderResultDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the order",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    success: bool = Field(
        ..., description="Whether the order was successfully canceled", examples=[False]
    )
    failureReason: Optional[FailureReason] = Field(
        None, description="Reason for cancelation failure"
    )


class ListOfCancelOrderResultDtos(BaseModel):
    data: List[CancelOrderResultDto] = Field(
        ..., description="Array of order cancelation results"
    )


class Type4(Enum):
    LIMIT = "LIMIT"
    MARKET = "MARKET"


class OrderFillDto(BaseModel):
    orderId: str = Field(
        ...,
        description="UUID of the order",
        examples=["b1234567-89ab-cdef-0123-456789abcdef"],
    )
    price: str = Field(
        ...,
        description="Fill price in expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Quantity filled in native units expressed as a decimal (precision: 9)",
        examples=["2.420"],
    )
    type: Type4 = Field(
        ...,
        description="The provided subaccount's order type e.g. MARKET or LIMIT",
        examples=["LIMIT"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    reduceOnly: bool = Field(
        ..., description="Indicates if the fill is reduce only", examples=[True]
    )
    feeUsd: str = Field(
        ...,
        description="The provided subaccount's charged fee in USD expressed as a decimal (precision: 9)",
        examples=["3.049563"],
    )
    isMaker: bool = Field(
        ..., description="Indicates if the fill was a maker or taker", examples=[True]
    )
    productId: str = Field(
        ...,
        description="UUID of product the order fill was made against",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp when this fill occurred",
        examples=["1721724269"],
    )


class ListOfOrderFillDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[OrderFillDto] = Field(..., description="Array of order fill objects")


class MakerSide(Enum):
    BUY = 0
    SELL = 1


class TakerSide(Enum):
    BUY = 0
    SELL = 1


class TradeDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the trade",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    takerOrderId: str = Field(
        ...,
        description="UUID of the taker order",
        examples=["b1234567-89ab-cdef-0123-456789abcdef"],
    )
    makerOrderId: str = Field(
        ...,
        description="UUID of the maker order",
        examples=["e3f0a8b7-6daa-498a-bf53-c16dc5e779de"],
    )
    makerFeeUsd: str = Field(
        ...,
        description="Maker fee in USD expressed as a decimal (precision: 9)",
        examples=["3.049563"],
    )
    takerFeeUsd: str = Field(
        ...,
        description="Taker fee in USD expressed as a decimal (precision: 9)",
        examples=["4.5743445"],
    )
    price: str = Field(
        ...,
        description="Price expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Quantity filled in native units expressed as a decimal (precision: 9)",
        examples=["2.420"],
    )
    makerSide: MakerSide = Field(
        ..., description="Maker side as either BUY (0) or SELL (1)", examples=[1]
    )
    takerSide: TakerSide = Field(
        ..., description="Taker side as either BUY (0) or SELL (1)", examples=[0]
    )
    productId: str = Field(
        ...,
        description="UUID of product the trade was made against",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp when this trade occurred",
        examples=["1721724269"],
    )


class ListOfTradeDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[TradeDto] = Field(..., description="Array of trade objects")


class PositionDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the position",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    avgPrice: str = Field(
        ...,
        description="Average price expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    size: str = Field(
        ...,
        description="Position size in native units expressed as a decimal (precision: 9)",
        examples=["1.5"],
    )
    fundingUsd: str = Field(
        ...,
        description="Amount in USD since position was opened expressed as a decimal (precision: 9)",
        examples=["10.5"],
    )
    feesAccruedUsd: str = Field(
        ...,
        description="Fees accrued in USD expressed as a decimal (precision: 9)",
        examples=["0.5"],
    )
    realizedPnl: str = Field(
        ...,
        description="Realized PnL in USD expressed as a decimal (precision: 9)",
        examples=["-12.5"],
    )
    productId: str = Field(
        ...,
        description="UUID of product to this position belongs to",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    updatedAt: float = Field(
        ...,
        description="Unix timestamp this position was last updated",
        examples=["1721724269"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp this position was created (i.e. opened)",
        examples=["1721724269"],
    )


class ListOfPositionDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[PositionDto] = Field(..., description="Array of position objects")


class ProductDto(BaseModel):
    id: str = Field(
        ...,
        description="UUID representing the registered product",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    ticker: str = Field(
        ...,
        description="Product ticker based on the base quote token",
        examples=["ETHUSD"],
    )
    displayTicker: str = Field(
        ...,
        description="Product display ticker based on the base quote token",
        examples=["ETH/USD"],
    )
    baseTokenAddress: str = Field(
        ...,
        description="Address of the base token (zero address if virtual)",
        examples=["0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"],
    )
    quoteTokenAddress: str = Field(
        ...,
        description="Address of quote token",
        examples=["0x4c9edd5852cd905f086c759e8383e09bff1e68b3"],
    )
    baseTokenName: str = Field(
        ..., description="Name of the base token (e.g. BTC in BTCUSD)", examples=["ETH"]
    )
    quoteTokenName: str = Field(
        ...,
        description="Name of the quote token (e.g. USD in BTCUSD)",
        examples=["USDe"],
    )
    engineType: EngineType = Field(
        ...,
        description="The corresponding engine type this product was registered with",
        examples=[0],
    )
    onchainId: float = Field(
        ...,
        description="The productId generated onchain after registering for the first time",
        examples=[1],
    )
    blockNumber: str = Field(
        ...,
        description="Block number this product was registered on",
        examples=["123062737"],
    )
    createdAt: float = Field(
        ...,
        description="Unix timestamp this product was registered",
        examples=[1721724269],
    )
    fundingUpdatedAt: Optional[float] = Field(
        None,
        description="Unix timestamp when funding was last updated",
        examples=[1721724269],
    )
    minQuantity: str = Field(
        ...,
        description="The minimum order quantity in native units expressed as a decimal (precision: 9)",
        examples=["0.05"],
    )
    lotSize: str = Field(
        ...,
        description="Quantity must be divisible by the lotSize in expressed as a decimal (precision: 9)",
        examples=["0.01"],
    )
    tickSize: str = Field(
        ...,
        description="Minimum price increment (tickSize) expressed as a decimal (precision: 9)",
        examples=["0.0001"],
    )
    liquidationMakerFee: str = Field(
        ...,
        description="Fee applied to the liquidator expressed as a decimal (precision: 9)",
        examples=["0.001"],
    )
    liquidationTakerFee: str = Field(
        ...,
        description="Fee applied to the liquidated expressed as a decimal (precision: 9)",
        examples=["0.02"],
    )
    makerFee: str = Field(
        ...,
        description="Fee charged to the maker on order trades expressed as a decimal (precision: 9)",
        examples=["0.001"],
    )
    takerFee: str = Field(
        ...,
        description="Fee charged to the taker on order trades expressed as a decimal (precision: 9)",
        examples=["0.004"],
    )
    maxQuantity: str = Field(
        ...,
        description="Max quantity per order in native units expressed as a decimal (precision: 9)",
        examples=["100000"],
    )
    minPrice: str = Field(
        ...,
        description="Min price in USD expressed as a decimal (precision: 9)",
        examples=["0"],
    )
    maxPrice: str = Field(
        ...,
        description="Max price in USD expressed as a decimal (precision: 9)",
        examples=["100000"],
    )
    maxLeverage: float = Field(
        ..., description="Maximum leverage allowed for the product", examples=[20]
    )
    hourlyFundingRate: str = Field(
        ...,
        description="Last computed hourly funding rate expressed as a decimal (precision: 9)",
        examples=["0.01"],
    )
    openInterest: str = Field(
        ...,
        description="Open interest in native units expressed as a decimal (precision: 9)",
        examples=["3300.17"],
    )
    maxOpenInterest: str = Field(
        ...,
        description="Max open interest in native units expressed as a decimal (precision: 9)",
        examples=["200000000.0"],
    )


class ListOfProductDtos(BaseModel):
    hasNext: bool = Field(
        ...,
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    nextCursor: Optional[str] = Field(
        None, description="Pointer to the next page in pagination dataset"
    )
    data: List[ProductDto] = Field(..., description="Array of product objects")


class MarketLiquidityDto(BaseModel):
    timestamp: float = Field(
        ...,
        description="Unix timestamp in ms of the most recent market liquidity update",
        examples=[1731664105881],
    )
    previousTimestamp: float = Field(
        ...,
        description="Unix timestamp in ms of the previous market liquidity update",
        examples=[1731664105881],
    )
    productId: str = Field(
        ...,
        description="UUID representing the product",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    asks: List[List[str]] = Field(
        ...,
        description="An array of ask tuple pairs (price, quantity) ordered in asc",
        examples=[[["4200.69", "1337.420"]]],
    )
    bids: List[List[str]] = Field(
        ...,
        description="An array of bid tuple pairs (price, quantity) ordered in desc",
        examples=[[["4199.42", "420.55"]]],
    )


class MarketPriceDto(BaseModel):
    productId: str = Field(
        ...,
        description="UUID representing the registered product",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    bestBidPrice: Optional[str] = Field(
        None,
        description="Best bid price in USD expressed as a decimal (precision: 9)",
        examples=["104399.65"],
    )
    bestAskPrice: Optional[str] = Field(
        None,
        description="Best ask price in USD expressed as a decimal (precision: 9)",
        examples=["104400.1"],
    )
    oraclePrice: Optional[str] = Field(
        None,
        description="Oracle price in USD expressed as a decimal (precision: 9)",
        examples=["104399.7"],
    )
    price24hAgo: Optional[str] = Field(
        None,
        description="Price of product 24hrs ago in USD expressed as a decimal (precision: 9)",
        examples=["101228.38"],
    )


class ListOfMarketPriceDtos(BaseModel):
    data: List[MarketPriceDto] = Field(..., description="Array of market price objects")


class FundingDto(BaseModel):
    ts: confloat(ge=1.0) = Field(
        ..., description="Timestamp of the funding update", examples=[1721724269]
    )
    hourlyFundingRate: str = Field(
        ..., description="Hourly funding rate", examples=["0.013876480"]
    )


class ListOfFundingDtos(BaseModel):
    data: List[FundingDto] = Field(
        ..., description="Array of funding rate history objects"
    )


class Order(Enum):
    asc = "asc"
    desc = "desc"


class OrderBy(Enum):
    createdAt = "createdAt"
    name = "name"


class V1SubaccountGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    name: Optional[constr(max_length=66)] = None
    sender: str = Field(..., examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"])
    orderBy: Optional[OrderBy] = Field(None, examples=["createdAt"])


class V1SubaccountBalanceGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])


class V1LinkedSignerQuotaGetParametersQuery(BaseModel):
    subaccountId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])


class OrderBy1(Enum):
    createdAt = "createdAt"
    expiresAt = "expiresAt"
    isActive = "isActive"


class V1LinkedSignerGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])
    active: Optional[bool] = Field(None, examples=[True])
    orderBy: Optional[OrderBy1] = Field(None, examples=["createdAt"])


class OrderBy2(Enum):
    createdAt = "createdAt"


class V1TokenWithdrawGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])
    active: Optional[bool] = Field(None, examples=[True])
    orderBy: Optional[OrderBy2] = Field(None, examples=["createdAt"])


class Status3(Enum):
    SUBMITTED = "SUBMITTED"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    REJECTED = "REJECTED"


class V1TokenTransferGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])
    statuses: Optional[List[Status3]] = Field(None, examples=["COMPLETED"])
    orderBy: Optional[OrderBy2] = Field(None, examples=["createdAt"])


class V1TokenGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    depositEnabled: Optional[bool] = Field(None, examples=[True])
    withdrawEnabled: Optional[bool] = Field(None, examples=[True])
    orderBy: Optional[OrderBy2] = Field(None, examples=["createdAt"])


class Status4(Enum):
    SUBMITTED = "SUBMITTED"
    NEW = "NEW"
    FILLED_PARTIAL = "FILLED_PARTIAL"
    FILLED = "FILLED"
    CANCELED = "CANCELED"
    REJECTED = "REJECTED"


class OrderBy5(Enum):
    type = "type"
    quantity = "quantity"
    price = "price"
    createdAt = "createdAt"


class V1OrderGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["c25c39d9-ce2b-4753-960c-c5ad558aace8"])
    productId: Optional[str] = Field(
        None, examples=["c25c39d9-ce2b-4753-960c-c5ad558aace8"]
    )
    statuses: Optional[List[Status4]] = Field(None, examples=["FILLED"])
    orderBy: Optional[OrderBy5] = Field(None, examples=["type"])


class OrderBy6(Enum):
    productId = "productId"
    filled = "filled"
    price = "price"
    createdAt = "createdAt"


class V1OrderFillGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["81215694-2d9f-4a87-af57-a710118938c0"])
    productId: Optional[str] = Field(
        None, examples=["93a1895f-5c34-421f-ba29-418f9c2f5fa6"]
    )
    statuses: Optional[List[Status4]] = None
    orderBy: Optional[OrderBy6] = Field(None, examples=["productId"])
    includeSelfTrades: Optional[bool] = Field(None, examples=[True])


class OrderBy7(Enum):
    createdAt = "createdAt"
    price = "price"
    filled = "filled"


class V1OrderTradeGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    productId: Optional[str] = Field(
        None, examples=["1b67d5b3-9dc7-4410-bc9c-7fd23ebd32ee"]
    )
    orderBy: Optional[OrderBy7] = Field(None, examples=["createdAt"])


class OrderBy8(Enum):
    size = "size"
    createdAt = "createdAt"


class V1PositionGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    subaccountId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])
    productId: Optional[str] = Field(
        None, examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"]
    )
    open: Optional[bool] = Field(None, examples=[True])
    orderBy: Optional[OrderBy8] = Field(None, examples=["size"])


class OrderBy9(Enum):
    createdAt = "createdAt"
    openInterest = "openInterest"
    baseTokenName = "baseTokenName"
    quoteTokenName = "quoteTokenName"


class V1ProductGetParametersQuery(BaseModel):
    order: Optional[Order] = Field(None, examples=["desc"])
    limit: Optional[float] = Field(None, examples=[100])
    cursor: Optional[str] = None
    orderBy: Optional[OrderBy9] = Field(None, examples=["createdAt"])
    ticker: Optional[constr(min_length=1, max_length=32)] = Field(
        None, examples=["ETHUSD"]
    )


class V1ProductMarketLiquidityGetParametersQuery(BaseModel):
    productId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])


class V1ProductMarketPriceGetParametersQuery(BaseModel):
    productIds: List[str] = Field(..., max_length=20, min_length=1)


class Range(Enum):
    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"


class V1FundingRateGetParametersQuery(BaseModel):
    productId: str = Field(..., examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"])
    range: Range = Field(..., examples=["DAY"])
