# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.simulator_info_base import SimulatorInfoBase
from ..core.pydantic_utilities import parse_obj_as
from ..errors.not_found_error import NotFoundError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.quantum_dot_array_simulation_execution_request import QuantumDotArraySimulationExecutionRequest
from ..types.simulators import Simulators
from ..types.simulator_result_info import SimulatorResultInfo
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SimulatorsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def info(self, *, request_options: typing.Optional[RequestOptions] = None) -> SimulatorInfoBase:
        """
        Retrieves a simulator's details.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SimulatorInfoBase
            Successful Response

        Examples
        --------
        from conductorquantum import ConductorQuantum

        client = ConductorQuantum(
            token="YOUR_TOKEN",
        )
        client.simulators.info()
        """
        _response = self._client_wrapper.httpx_client.request(
            f"simulators/quantum-dot-array-simulator",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SimulatorInfoBase,
                    parse_obj_as(
                        type_=SimulatorInfoBase,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> typing.List[SimulatorInfoBase]:
        """
        Retrieves a list of available simulators.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[SimulatorInfoBase]
            Successful Response

        Examples
        --------
        from conductorquantum import ConductorQuantum

        client = ConductorQuantum(
            token="YOUR_TOKEN",
        )
        client.simulators.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "simulators",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[SimulatorInfoBase],
                    parse_obj_as(
                        type_=typing.List[SimulatorInfoBase],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def execute(
        self,
        *,
        options: QuantumDotArraySimulationExecutionRequest,
        simulator: typing.Optional[Simulators] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SimulatorResultInfo:
        """
        Executes a simulator with the provided data.

        Parameters
        ----------
        options : QuantumDotArraySimulationExecutionRequest

        simulator : typing.Optional[Simulators]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SimulatorResultInfo
            Successful Response

        Examples
        --------
        from conductorquantum import (
            ConductorQuantum,
            QuantumDotArraySimulationExecutionRequest,
        )

        client = ConductorQuantum(
            token="YOUR_TOKEN",
        )
        client.simulators.execute(
            options=QuantumDotArraySimulationExecutionRequest(
                c_dot_dot=[[1.1]],
                c_gate_dot=[[1.1]],
                x_axis_gate="x_axis_gate",
                y_axis_gate="y_axis_gate",
                num_points_x_axis_gate=1,
                num_points_y_axis_gate=1,
                x_axis_start=1.1,
                x_axis_end=1.1,
                y_axis_start=1.1,
                y_axis_end=1.1,
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "simulators",
            method="POST",
            json={
                "simulator": simulator,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=QuantumDotArraySimulationExecutionRequest, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SimulatorResultInfo,
                    parse_obj_as(
                        type_=SimulatorResultInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSimulatorsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def info(self, *, request_options: typing.Optional[RequestOptions] = None) -> SimulatorInfoBase:
        """
        Retrieves a simulator's details.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SimulatorInfoBase
            Successful Response

        Examples
        --------
        import asyncio

        from conductorquantum import AsyncConductorQuantum

        client = AsyncConductorQuantum(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.simulators.info()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"simulators/quantum-dot-array-simulator",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SimulatorInfoBase,
                    parse_obj_as(
                        type_=SimulatorInfoBase,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> typing.List[SimulatorInfoBase]:
        """
        Retrieves a list of available simulators.

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[SimulatorInfoBase]
            Successful Response

        Examples
        --------
        import asyncio

        from conductorquantum import AsyncConductorQuantum

        client = AsyncConductorQuantum(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.simulators.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "simulators",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[SimulatorInfoBase],
                    parse_obj_as(
                        type_=typing.List[SimulatorInfoBase],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def execute(
        self,
        *,
        options: QuantumDotArraySimulationExecutionRequest,
        simulator: typing.Optional[Simulators] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SimulatorResultInfo:
        """
        Executes a simulator with the provided data.

        Parameters
        ----------
        options : QuantumDotArraySimulationExecutionRequest

        simulator : typing.Optional[Simulators]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SimulatorResultInfo
            Successful Response

        Examples
        --------
        import asyncio

        from conductorquantum import (
            AsyncConductorQuantum,
            QuantumDotArraySimulationExecutionRequest,
        )

        client = AsyncConductorQuantum(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.simulators.execute(
                options=QuantumDotArraySimulationExecutionRequest(
                    c_dot_dot=[[1.1]],
                    c_gate_dot=[[1.1]],
                    x_axis_gate="x_axis_gate",
                    y_axis_gate="y_axis_gate",
                    num_points_x_axis_gate=1,
                    num_points_y_axis_gate=1,
                    x_axis_start=1.1,
                    x_axis_end=1.1,
                    y_axis_start=1.1,
                    y_axis_end=1.1,
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "simulators",
            method="POST",
            json={
                "simulator": simulator,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=QuantumDotArraySimulationExecutionRequest, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SimulatorResultInfo,
                    parse_obj_as(
                        type_=SimulatorResultInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
