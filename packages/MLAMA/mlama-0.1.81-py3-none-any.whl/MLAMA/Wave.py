# -*- coding: utf-8 -*-
"""Wave.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HjQ_HMGOhGvAU_5tWiW6z0QR_BS9BK29
"""

import datetime

# #Wave class to represent each waves
# #Wave.py
# class Wave:
#   """
#   A class to represent a wave.
#   Attributes:
#     waveID (int): Unique ID for each wave
#     startDate (Date object): Start date of the wave
#     endDate (Date object): End date of the wave
#     trainStartDate (Date object): Start date of the training data
#     trainEndDate (Date object): End date of the training data
#     testStartDate (Date object): Start date of the testing data
#     testEndDate (Date object): End date of the testing data
#     df (DataFrame): Dataframe of the wave
#   Methods:
#     print_wave: Prints the wave information
#     get_wave_dates_with_delay: Gets the wave data, train data, and test data with delay
#     get_wave_test_start_date_with_delay: Gets the test start date with delay
#     get_wave_df: Gets the wave data as a dataframe
#   """
#   def __init__(self, waveID, startDate, endDate,
#                trainStartDate, trainEndDate, testStartDate, testEndDate, delay_list, df):
#     """
#     Constructs all the necessary attributes for the wave object.
#     Args:
#       waveID (int): Unique ID for each wave
#       startDate (Date object): Start date of the wave
#       endDate (Date object): End date of the wave
#       trainStartDate (Date object): Start date of the training data
#       trainEndDate (Date object): End date of the training data
#       testStartDate (Date object): Start date of the testing data
#       testEndDate (Date object): End date of the testing data
#       df (DataFrame): Dataframe of the wave
#     """
#     self.waveID = waveID
#     self.startDate = startDate
#     self.endDate = endDate

#     self.trainStartDate = trainStartDate
#     self.trainEndDate = trainEndDate
#     self.testStartDate = testStartDate
#     self.testEndDate = testEndDate

#     self.max_delay = max(delay_list)

#     sliding_room = datetime.timedelta(weeks=self.max_delay)
#     e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
#     end = e + sliding_room#end extra to allow for sliding room, for different Prediction lengths and delays
#     end_str = end.strftime("%Y-%m-%d")

#     self.df = df.loc[self.startDate:end_str]#+wiggle room which is = max_delay

#   def print_wave(self):
#     print('Wave', self.waveID, ':')
#     print('All:', self.startDate, ':', self.endDate)
#     print('Maximum Delay: ', self.max_delay)
#     print('Train:', self.trainStartDate, ':', self.trainEndDate)
#     print('Test:', self.testStartDate, ':', self.testEndDate)



#   def get_wave_dates_with_delay_delay(self, delay, delayed_start_matrix):#JMM definition.
#     """
#     Gets the wave data, train data, and test data after calculating delay.
#     Wave start remains the same, wave end delayed.
#     Train start remains the same, train end not delayed (Mahmood definition). (Only change than Yushu definition)
#     Test start and end delayed.
#     Args:
#       wave:Wave object
#       delay (int): Delay in weeks
#     Returns:
#       wave_data (DataFrame): Wave data with delay
#       train_data (DataFrame): Train data with delay
#       test_data (DataFrame): Test data with delay
#     """
#     ############WAVE data
#     delayed_start = delayed_start_matrix[str(self.waveID)][delay]
#     #for the waves start is also delayed
#     s = datetime.datetime.strptime(self.startDate,"%Y-%m-%d")#start fixed, irrespective of delay
#     w = datetime.timedelta(weeks=delayed_start)
#     start = s + w#end delayed
#     start_str = start.strftime("%Y-%m-%d")

#     e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e + w#end delayed
#     end_str = end.strftime("%Y-%m-%d")
#     #print('Wave:', start_str, ':', end_str)
#     wave_data = self.df.loc[start_str:end_str]

#     ############Train data
#     #start don't need to calculate again. same as wave start
#     #start = datetime.datetime.strptime(self.trainStartDate,"%Y-%m-%d")#train start fixed, irrespective of delay
#     #start_str = start.strftime("%Y-%m-%d")

#     e = datetime.datetime.strptime(self.trainEndDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e #end not delayed
#     end_str = end.strftime("%Y-%m-%d")
#     #print('Train:', start_str, ':', end_str)
#     train_data = self.df.loc[start_str:end_str]

#     ############Test data
#     #trainEndDate here, that's how Yushu plotted the lines#but this will make incorrect predictions, for plot maybe do one week subtract if needed. so, testStartDate
#     #next week of train end
#     #s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")#test start date delayed
#     w = datetime.timedelta(weeks=delay+1)
#     start = e + w #test start date delayed
#     start_str = start.strftime("%Y-%m-%d")

#     #end same as wave end date actually
#     e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e + w#end delayed
#     end_str = end.strftime("%Y-%m-%d")
#     #print('Test:', start_str, ':', end_str)
#     test_data = self.df.loc[start_str:end_str]


#     return wave_data, train_data, test_data


#   def get_wave_dates_with_delay_responsiveness(self, delay, delayed_start_matrix):#yushu definition.
#     """
#     Gets the wave data, train data, and test data after calculating delay.
#     Wave start remains the same, wave end delayed. Train start remains the same, train end delayed. Test start and end delayed.
#     Args:
#       wave:Wave object
#       delay (int): Delay in weeks
#     Returns:
#       wave_data (DataFrame): Wave data with delay
#       train_data (DataFrame): Train data with delay
#       test_data (DataFrame): Test data with delay
#     """
#     ############WAVE data
#     print(delay)
#     delayed_start = delayed_start_matrix[str(self.waveID)][delay]
#     #for the waves start is also delayed
#     s = datetime.datetime.strptime(self.startDate,"%Y-%m-%d")#start fixed, irrespective of delay
#     w = datetime.timedelta(weeks=delayed_start)
#     start = s + w#start delayed
#     start_str = start.strftime("%Y-%m-%d")

#     e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e + w#end delayed
#     end_str = end.strftime("%Y-%m-%d")
#     #print('Wave:', start_str, ':', end_str)
#     wave_data = self.df.loc[start_str:end_str]

#     ############Train data
#     #start don't need to calculate again. train start same as wave start

#     #start = datetime.datetime.strptime(self.trainStartDate,"%Y-%m-%d")#train start fixed, irrespective of delay
#     #start_str = start.strftime("%Y-%m-%d")

#     e = datetime.datetime.strptime(self.trainEndDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e + w#end delayed
#     end_str = end.strftime("%Y-%m-%d")
#     #print('Train:', start_str, ':', end_str)
#     train_data = self.df.loc[start_str:end_str]

#     ############Test data
#     #trainEndDate here, that's how Yushu plotted the lines#but this will make incorrect predictions, for plot maybe do one week subtract if needed. so, testStartDate
#     #next week of train end
#     #s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")#test start date delayed
#     w = datetime.timedelta(weeks=delay+1)#next of train end date
#     start = e + w #test start date delayed
#     start_str = start.strftime("%Y-%m-%d")

#     #end same as wave end date actually
#     e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e + w#end delayed
#     end_str = end.strftime("%Y-%m-%d")
#     #print('Test:', start_str, ':', end_str)
#     test_data = self.df.loc[start_str:end_str]

#     return wave_data, train_data, test_data


#   def get_wave_test_start_date_with_delay(self, delay):#need to change this, yushu definition.
#     """
#     Gets the test start date, enddate after calculating delay. Test start and end delayed.
#     for plot display
#     Args:
#       wave:Wave object
#       delay (int): Delay in weeks
#     Returns:
#       start_str (string): Test start date with delay
#       end_str (string): Test end date with delay
#     """
#     s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")##test start date delayed
#     w = datetime.timedelta(weeks=delay)
#     start = s + w #test start date delayed
#     start_str = start.strftime("%Y-%m-%d")

#     e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
#     w = datetime.timedelta(weeks=delay)
#     end = e + w#end delayed
#     end_str = end.strftime("%Y-%m-%d")

#     return start_str, end_str


#   def get_wave_df(self):
#     """
#     Gets the wave data (from start date to end date) as a dataframe.
#     Returns:
#       self.df (DataFrame): Wave data as a dataframe
#     """
#     #return self.df[self.startDate:self.endDate]
#     return self.df.loc[self.startDate:self.endDate]

#   def get_wave_dates_with_delay(self, delay, delayed_start_matrix, delay_definition_flag = 'Responsiveness'):
#     """
#     Gets the wave data, train data, and test data after calculating delay.

#     Args:
#       wave:Wave object
#       delay (int): Delay in weeks
#       delayed_start_matrix: for the later waves' start dates are shifted
#       Yushu (boolean): True if Yushu's definition, False if JMM's definition
#     Returns:
#       wave_data (DataFrame): Wave data with delay
#       train_data (DataFrame): Train data with delay
#       test_data (DataFrame): Test data with delay
#     """
#     if delay_definition_flag == 'Delay':
#       return self.get_wave_dates_with_delay_delay(delay, delayed_start_matrix)

#     return self.get_wave_dates_with_delay_responsiveness(delay, delayed_start_matrix)

# #####################################

#Wave class to represent each waves
#Wave.py
class Wave:
  """
  A class to represent a wave.
  Attributes:
    waveID (int): Unique ID for each wave
    startDate (Date object): Start date of the wave
    endDate (Date object): End date of the wave
    trainStartDate (Date object): Start date of the training data
    trainEndDate (Date object): End date of the training data
    testStartDate (Date object): Start date of the testing data
    testEndDate (Date object): End date of the testing data
    df (DataFrame): Dataframe of the wave
  Methods:
    print_wave: Prints the wave information
    get_wave_dates_with_delay: Gets the wave data, train data, and test data with delay
    get_wave_test_start_date_with_delay: Gets the test start date with delay
    get_wave_df: Gets the wave data as a dataframe
  """
  def __init__(self, waveID, startDate, endDate,
               trainStartDate, trainEndDate, testStartDate, testEndDate, delay_list, df):
    """
    Constructs all the necessary attributes for the wave object.
    Args:
      waveID (int): Unique ID for each wave
      startDate (Date object): Start date of the wave
      endDate (Date object): End date of the wave
      trainStartDate (Date object): Start date of the training data
      trainEndDate (Date object): End date of the training data
      testStartDate (Date object): Start date of the testing data
      testEndDate (Date object): End date of the testing data
      df (DataFrame): Dataframe of the wave
    """
    self.waveID = waveID
    self.startDate = startDate
    self.endDate = endDate

    self.trainStartDate = trainStartDate
    self.trainEndDate = trainEndDate
    self.testStartDate = testStartDate
    self.testEndDate = testEndDate

    self.max_delay = max(delay_list)

    sliding_room = datetime.timedelta(weeks=self.max_delay)
    e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
    end = e + sliding_room#end extra to allow for sliding room, for different Prediction lengths and delays
    end_str = end.strftime("%Y-%m-%d")
    self.all_df = df
    self.df = df.loc[self.startDate:end_str]#+wiggle room which is = max_delay. so this df is not actual wave start end, it conatins wiggle room

  def print_wave(self):
    print('Wave', self.waveID, ':')
    print('All:', self.startDate, ':', self.endDate)
    print('Maximum Delay: ', self.max_delay)
    print('Train:', self.trainStartDate, ':', self.trainEndDate)
    print('Test:', self.testStartDate, ':', self.testEndDate)


  def add_one_week(self, week_data):#for adding future  data to the current data
    """
    Gets the test start date, enddate after calculating delay. Test start and end delayed.
    for plot display
    Args:
      week_data: one week data, dont need it, i might need ow many weeks i want to add
    Returns:
      self/nothing
    """
    # s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")##test start date delayed
    # w = datetime.timedelta(weeks=delay)
    # start = s + w #test start date delayed
    # start_str = start.strftime("%Y-%m-%d")
    # wave_df = self.df.loc[self.startDate:self.endDate]
    # self.df = pd.concat([self.df, week_data])
    # self.df = self.df[~self.df.index.duplicated(keep='first')]


    e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=1)#new wave end date, one new week added
    end = e + w #new wave end date
    self.endDate = end.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.trainEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=1)#new train end date
    end = e + w #
    self.trainEndDate = end.strftime("%Y-%m-%d")

    w = datetime.timedelta(weeks=2)#next of train end date, so 2 weeks after old tarin enddate
    start = e + w #test start date delayed, a day after train end
    self.testStartDate = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=1)
    end = e + w#test end delayed by one week
    self.testEndDate = end.strftime("%Y-%m-%d")

    sliding_room = datetime.timedelta(weeks=self.max_delay)
    e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
    end = e + sliding_room#end extra to allow for sliding room, for different Prediction lengths and delays
    end_str = end.strftime("%Y-%m-%d")#new sliding rom

    self.df = self.all_df.loc[self.startDate:end_str]#+wiggle room which is = max_delay. so this df is not actual wave start end, it conatins wiggle room


  def get_wave_dates_with_delay_delay(self, delay, delayed_start_matrix):#JMM definition. get_wave_dates_with_shift_delay
    """
    Gets the wave data, train data, and test data after calculating delay.
    Wave start remains the same, wave end delayed.
    Train start remains the same, train end not delayed (Mahmood definition). (Only change than Yushu definition)
    Test start and end delayed.
    Args:
      wave:Wave object
      delay (int): Delay in weeks
    Returns:
      wave_data (DataFrame): Wave data with delay
      train_data (DataFrame): Train data with delay
      test_data (DataFrame): Test data with delay
    """
    ############WAVE data
    delayed_start = delayed_start_matrix[str(self.waveID)][delay]
    #for the waves start is also delayed
    s = datetime.datetime.strptime(self.startDate,"%Y-%m-%d")#start fixed, irrespective of delay
    w = datetime.timedelta(weeks=delayed_start)
    start = s + w#end delayed
    start_str = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e + w#end delayed
    end_str = end.strftime("%Y-%m-%d")
    #print('Wave:', start_str, ':', end_str)
    wave_data = self.df.loc[start_str:end_str]

    ############Train data
    #start don't need to calculate again. same as wave start
    #start = datetime.datetime.strptime(self.trainStartDate,"%Y-%m-%d")#train start fixed, irrespective of delay
    #start_str = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.trainEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e #end not delayed
    end_str = end.strftime("%Y-%m-%d")
    #print('Train:', start_str, ':', end_str)
    train_data = self.df.loc[start_str:end_str]

    ############Test data
    #trainEndDate here, that's how Yushu plotted the lines#but this will make incorrect predictions, for plot maybe do one week subtract if needed. so, testStartDate
    #next week of train end
    #s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")#test start date delayed
    w = datetime.timedelta(weeks=delay+1)
    start = e + w #test start date delayed
    start_str = start.strftime("%Y-%m-%d")

    #end same as wave end date actually
    e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e + w#end delayed
    end_str = end.strftime("%Y-%m-%d")
    #print('Test:', start_str, ':', end_str)
    test_data = self.df.loc[start_str:end_str]


    return wave_data, train_data, test_data


  def get_wave_dates_with_delay_responsiveness(self, delay, delayed_start_matrix):#yushu definition.#get_wave_dates_with_shift_responsiveness
    """
    Gets the wave data, train data, and test data after calculating delay.
    Wave start remains the same, wave end delayed. Train start remains the same, train end delayed. Test start and end delayed.
    Args:
      wave:Wave object
      delay (int): Delay in weeks
    Returns:
      wave_data (DataFrame): Wave data with delay
      train_data (DataFrame): Train data with delay
      test_data (DataFrame): Test data with delay
    """
    ############WAVE data
    delayed_start = delayed_start_matrix[str(self.waveID)][delay]
    #for the waves start is also delayed
    s = datetime.datetime.strptime(self.startDate,"%Y-%m-%d")#start fixed, irrespective of delay
    w = datetime.timedelta(weeks=delayed_start)
    start = s + w#start delayed
    start_str = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.endDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e + w#end delayed
    end_str = end.strftime("%Y-%m-%d")
    #print('Wave:', start_str, ':', end_str)
    wave_data = self.df.loc[start_str:end_str]

    ############Train data
    #start don't need to calculate again. train start same as wave start

    #start = datetime.datetime.strptime(self.trainStartDate,"%Y-%m-%d")#train start fixed, irrespective of delay
    #start_str = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.trainEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e + w#end delayed
    end_str = end.strftime("%Y-%m-%d")
    #print('Train:', start_str, ':', end_str)
    train_data = self.df.loc[start_str:end_str]

    ############Test data
    #trainEndDate here, that's how Yushu plotted the lines#but this will make incorrect predictions, for plot maybe do one week subtract if needed. so, testStartDate
    #next week of train end
    #s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")#test start date delayed
    w = datetime.timedelta(weeks=delay+1)#next of train end date
    start = e + w #test start date delayed, a day after train end
    start_str = start.strftime("%Y-%m-%d")

    #end same as wave end date actually
    e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e + w#end delayed
    end_str = end.strftime("%Y-%m-%d")
    #print('Test:', start_str, ':', end_str)
    test_data = self.df.loc[start_str:end_str]

    return wave_data, train_data, test_data

  def get_wave_test_start_date_with_delay(self, delay):#need to change this, yushu definition.
    """
    Gets the test start date, enddate after calculating delay. Test start and end delayed.
    for plot display
    Args:
      wave:Wave object
      delay (int): Delay in weeks
    Returns:
      start_str (string): Test start date with delay
      end_str (string): Test end date with delay
    """
    # s = datetime.datetime.strptime(self.testStartDate,"%Y-%m-%d")##test start date delayed
    # w = datetime.timedelta(weeks=delay)
    # start = s + w #test start date delayed
    # start_str = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.trainEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay+1)#next of train end date
    start = e + w #test start date delayed, a day after train end
    start_str = start.strftime("%Y-%m-%d")

    e = datetime.datetime.strptime(self.testEndDate,"%Y-%m-%d")
    w = datetime.timedelta(weeks=delay)
    end = e + w#end delayed
    end_str = end.strftime("%Y-%m-%d")

    return start_str, end_str


  def get_wave_df(self):
    """
    Gets the wave data (from start date to end date) as a dataframe.
    Returns:
      self.df (DataFrame): Wave data as a dataframe
    """
    #return self.df[self.startDate:self.endDate]
    return self.df.loc[self.startDate:self.endDate]

  def get_wave_dates_with_delay(self, delay, delayed_start_matrix, delay_definition_flag='Responsiveness'):
    """
    Gets the wave data, train data, and test data after calculating delay.

    Args:
      delay (int): Delay in weeks.
      delayed_start_matrix: Matrix for shifting later waves' start dates.
      delay_definition_flag (str): Should be either 'Delay' or 'Responsiveness'.

    Returns:
      DataFrame: Wave data with delay.
    """
    if delay_definition_flag not in ['Delay', 'Responsiveness']:
        raise ValueError("Invalid delay_definition_flag. Expected 'Delay' or 'Responsiveness'.")

    if delay_definition_flag == 'Delay':
        return self.get_wave_dates_with_delay_delay(delay, delayed_start_matrix)

    return self.get_wave_dates_with_delay_responsiveness(delay, delayed_start_matrix)


#####################################

#Wave.py

def generate_test_start_date(test_end_date, predictions):
  """
  Generates the test start date.
  Args:
    test_end_date (string): Test end date
    test_length (int): Test length
  Returns:
    test_start_date (string): Test start date
  """
  test_length = max(predictions)
  e = datetime.datetime.strptime(test_end_date,"%Y-%m-%d")#test start date delayed
  w = datetime.timedelta(weeks=test_length-1)
  test_start_date = (e - w).strftime("%Y-%m-%d")
  return test_start_date

def generate_train_end_date(wave_end_date, predictions):
  """
  Generates the train end date.
  Args:
    wave_end_date (string): Wave end date
    test_length (int): Test length
  Returns:
    train_end_date (string): Train end date
  """
  test_length = max(predictions)
  e = datetime.datetime.strptime(wave_end_date,"%Y-%m-%d")#test start date delayed
  w = datetime.timedelta(weeks=test_length)
  train_end_date = (e - w).strftime("%Y-%m-%d")
  return train_end_date