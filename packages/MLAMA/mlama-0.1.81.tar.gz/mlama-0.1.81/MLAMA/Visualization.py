# -*- coding: utf-8 -*-
"""Visualization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fdbWbsZgYTqDMrbVlC0MVfjGy8HRutCm
"""

from pandas import read_csv
from pandas import DataFrame
from pandas import concat
import pandas as pd
import numpy as np
import matplotlib.dates as mdates
import matplotlib.colors as mcolors
import matplotlib.pyplot as plt
from .Predictions import individual_model_weekly_count, individual_model_weekly_MAPE
from .Processor import process_metrics_df, find_model_week_values_sum_delay

#generalized version
# def visualize_weekly_case_count_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
#     """
#     Visualizes weekly case counts with predictions for ARIMA and ML models.
#     """
#     # Generate per-model metrics (A_dict, B_dict, etc.)
#     model_dicts = individual_model_weekly_count(WAVES, predictions, delay_list, model_evaluation_dictionary, models, recent_week_count)
#     #print(model_dicts)
#     #model_dicts = {}
#     #for model_name in models.keys():
#         #model_dicts[model_name] = model_results[model_name]

#     max_x_tick = 25  # Maximum number of x-tick labels

#     for WAVE in WAVES:
#         waveID = WAVE.waveID
#         #print("Wave: ", waveID)

#         fig = plt.figure(figsize=(25, 25))
#         gs = fig.add_gridspec(len(predictions) + 1, len(delay_list), hspace=0.2, wspace=0.2)

#         time = WAVE.get_wave_df().tail(recent_week_count).reset_index(drop=False)

#         for delay in delay_list:
#             from_date, to_date = WAVE.get_wave_test_start_date_with_delay(delay)

#             for prediction_length in predictions:
#                 ax = fig.add_subplot(gs[prediction_length, delay])
#                 plt.subplots_adjust(left=0.04, right=0.9, top=0.9, bottom=0.01)

#                 # Plot each model's predictions dynamically

#                 for model_name, model_data in model_dicts.items():
#                     wave_model_data = model_data[waveID][delay]

#                     #print(wave_model_data)
#                     column_name = f"{model_name}_{prediction_length}"
#                     #print('column_name: ', column_name)
#                     #print(wave_model_data.columns)
#                     #print('model_name: ', model_name, 'waveID', waveID, 'delay', delay, 'prediction_length', prediction_length)
#                     if column_name in wave_model_data.columns:

#                         ax.plot(wave_model_data[column_name].dropna(), label=model_name, linewidth=2)

#                 # Scatter plot for observed weekly cases
#                 ax.scatter(time['week'], time['weekcase'], color='black', label='Observed', zorder=3)

#                 # Customize Axes
#                 ax.axvline(x=from_date, color='grey', linestyle="--")
#                 ax.axvline(x=to_date, color='grey', linestyle="--")
#                 if delay == 0:
#                     plt.ylabel(f"Prediction Length = {prediction_length} Week")
#                 if prediction_length == 1:
#                     ax.set_title(f"Delay = {delay} Week")
#                 if prediction_length == 6:
#                     ax.tick_params(axis='x', labelrotation=90)
#                 else:
#                     ax.set_xticklabels([])
#                     ax.set_xticks([])

#         ax.legend(bbox_to_anchor=(-0.5, -0.5), ncol=4, fontsize=20)
#         fig.text(0, 0.5, f'Weekly Case Count, Wave = {waveID}', va='center', rotation='vertical', fontsize="20")
#         plt.show()


def visualize_weekly_case_count_all_model_each_wave(WAVES, predictions, delay_list, delayed_start_matrix, model_evaluation_dictionary, recent_week_count, models):
    """
    Visualizes weekly case counts with predictions for ARIMA and ML models.
    """
    # Generate per-model metrics (A_dict, B_dict, etc.)
    model_dicts = individual_model_weekly_count(WAVES, predictions, delay_list, model_evaluation_dictionary, models, recent_week_count)
    print(model_dicts)
    #model_dicts = {}
    #for model_name in models.keys():
        #model_dicts[model_name] = model_results[model_name]

    max_x_tick = 25  # Maximum number of x-tick labels

    for WAVE in WAVES:
        waveID = WAVE.waveID
        #print("Wave: ", waveID)

        fig = plt.figure(figsize=(25, 25))
        gs = fig.add_gridspec(len(predictions) + 1, len(delay_list), hspace=0.2, wspace=0.2)

        time = WAVE.get_wave_df().tail(recent_week_count).reset_index(drop=False)

        for delay in delay_list:
            from_date, to_date = WAVE.get_wave_test_start_date_with_delay(delay)
            delayed_wave, _, _ = WAVE.get_wave_dates_with_delay_delay(delay, delayed_start_matrix)
            time = delayed_wave.tail(recent_week_count).reset_index(drop=False)
            print("Wave: ", waveID, "Delay: ", delay, 'from: ', from_date, to_date)
            for prediction_length in predictions:
                ax = fig.add_subplot(gs[prediction_length, delay])
                plt.subplots_adjust(left=0.04, right=0.9, top=0.9, bottom=0.01)

                # Plot each model's predictions dynamically

                for model_name, model_data in model_dicts.items():
                    wave_model_data = model_data[waveID][delay]

                    #print(f"{model_name}: {wave_model_data}")
                    column_name = f"{model_name}_{prediction_length}"
                    #print('column_name: ', column_name)
                    #print(wave_model_data[column_name].dropna())
                    #print(wave_model_data.columns)
                    #print('model_name: ', model_name, 'waveID', waveID, 'delay', delay, 'prediction_length', prediction_length)
                    if column_name in wave_model_data.columns:
                        ax.plot(wave_model_data[column_name].dropna(), label=model_name, linewidth=2)

                # Scatter plot for observed weekly cases
                #print('time[week]', time['week'])
                ax.scatter(time['week'], time['weekcase'], color='black', label='Observed', zorder=3)

                # Customize Axes
                ax.axvline(x=from_date, color='grey', linestyle="--")
                ax.axvline(x=to_date, color='grey', linestyle="--")
                if delay == 0:
                    plt.ylabel(f"Prediction Length = {prediction_length} Week")
                if prediction_length == 1:
                    ax.set_title(f"Delay = {delay} Week")
                if prediction_length == 6:
                    ax.tick_params(axis='x', labelrotation=90)
                else:
                    ax.set_xticklabels([])
                    ax.set_xticks([])

        ax.legend(bbox_to_anchor=(-0.5, -0.5), ncol=4, fontsize=20)
        fig.text(0, 0.5, f'Weekly Case Count, Wave = {waveID}', va='center', rotation='vertical', fontsize="20")
        plt.show()



#generalized

from matplotlib.colors import ListedColormap
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# def visualize_weekly_MAPE_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
#     """
#     Generalized function to visualize weekly MAPE for multiple models across waves.

#     Parameters:
#         WAVES: List of wave objects containing wave IDs.
#         predictions: Model predictions.
#         delay_list: List of delays for predictions.
#         model_evaluation_dictionary: Dictionary of evaluation results.
#         recent_week_count: Number of recent weeks to consider.
#         models: Dictionary of models to visualize with their keys and associated methods (e.g., {'ARIMA': SARIMAX, 'RF': RandomForestRegressor}).
#     """
#     model_results_wave_collection = individual_model_weekly_MAPE(WAVES, predictions, delay_list, model_evaluation_dictionary, models)
#     mape_wave_delay = {}
#     print('individual_model_weekly_MAPE DONE')
#     for WAVE in WAVES:  # Iterate over each wave
#         waveID = WAVE.waveID
#         fig, axes = plt.subplots(len(models), len(delay_list), sharex=True, sharey=True, figsize=(25, 10))
#         gs = fig.add_gridspec(len(models), len(delay_list), hspace=0.2, wspace=0.2)
#         plt.subplots_adjust(left=0.08, right=0.9, top=0.9, bottom=0.1)

#         for model_index, (model_name, model_class) in enumerate(models.items()):  # Dynamically iterate over models
#             model_results_collection = model_results_wave_collection[model_name][waveID]

#             for delay in delay_list:  # Iterate over delays
#                 ax = axes[model_index, delay]
#                 mape_delay = pd.DataFrame()
#                 weeks = [x - 1 for x in predictions]
#                 print(weeks)
#                 # Retrieve and plot model results
#                 all_week_list, values_list = find_model_week_values_sum_delay(model_results_collection, delay, weeks)
#                 values_df = pd.DataFrame(values_list)
#                 values_df.columns = [model_name]
#                 #print('okk')
#                 # Bar and line plot
#                 all_week_list.plot(
#                     kind='bar',
#                     stacked=False,
#                     width=1,
#                     colormap=ListedColormap(sns.color_palette("muted", 10)),
#                     figsize=(13, 15),
#                     ax=ax
#                 )
#                 ax.plot(values_list, label="MAPE", marker='o')  # Line plot with markers
#                 ax.scatter(range(len(values_list)), values_list, color='red', label="MAPE Points", zorder=3)  # Scatter plot for individual points

#                 ax.set_title(f"Delay = {delay} Week ")
#                 ax.get_legend().remove()

#                 mape_delay = pd.concat([mape_delay, values_df], axis=1, join='inner')  # Concatenate MAPE results
#                 mape_wave_delay[waveID] = mape_delay

#                 # Labeling
#                 if delay == 0:
#                     ax.set_ylabel(model_name)
#                 if delay == len(delay_list) - 1 and model_index == len(models) - 1:
#                     ax.legend(
#                         ["MAPE", 'First Week', 'Second Week', 'Third Week', 'Fourth Week', 'Fifth Week', 'Sixth Week'],
#                         loc='lower center',
#                         bbox_to_anchor=(-2, -0.3),
#                         ncol=7
#                     )

#         # Super labels
#         fig.supxlabel(f"Prediction Length (Week), Wave = {waveID}")
#         fig.supylabel("MAPE %")

#     return mape_wave_delay


def visualize_weekly_MAPE_all_model_each_wave(WAVES, predictions, delay_list, model_evaluation_dictionary, recent_week_count, models):
    """
    Generalized function to visualize weekly MAPE for multiple models across waves.

    Parameters:
        WAVES: List of wave objects containing wave IDs.
        predictions: Model predictions.
        delay_list: List of delays for predictions.
        model_evaluation_dictionary: Dictionary of evaluation results.
        recent_week_count: Number of recent weeks to consider.
        models: Dictionary of models to visualize with their keys and associated methods (e.g., {'ARIMA': SARIMAX, 'RF': RandomForestRegressor}).
    """
    model_results_wave_collection = individual_model_weekly_MAPE(WAVES, predictions, delay_list, model_evaluation_dictionary, models)
    mape_wave_delay = {}
    print('individual_model_weekly_MAPE DONE')
    for WAVE in WAVES:  # Iterate over each wave
        waveID = WAVE.waveID
        fig, axes = plt.subplots(len(models), len(delay_list), sharex=True, sharey=True, figsize=(25, 10))
        gs = fig.add_gridspec(len(models), len(delay_list), hspace=0.2, wspace=0.2)
        plt.subplots_adjust(left=0.08, right=0.9, top=0.9, bottom=0.1)

        for model_index, (model_name, model_class) in enumerate(models.items()):  # Dynamically iterate over models
            model_results_collection = model_results_wave_collection[model_name][waveID]

            for delay in delay_list:  # Iterate over delays
                ax = axes[model_index, delay]
                mape_delay = pd.DataFrame()
                weeks = [x - 1 for x in predictions]
                #print('model_results_collection', model_results_collection)
                # Retrieve and plot model results
                all_week_list, values_list = find_model_week_values_sum_delay(model_results_collection, delay, weeks)
                values_df = pd.DataFrame(values_list)
                values_df.columns = [model_name]
                #print('okk')
                # Bar and line plot
                all_week_list.plot(
                    kind='bar',
                    stacked=False,
                    width=1,
                    colormap=ListedColormap(sns.color_palette("muted", 10)),
                    figsize=(13, 15),
                    ax=ax
                )
                #ax.plot(values_list, label="MAPE")
                ax.plot(values_list, label="MAPE", marker='o')  # Line plot with markers
                ax.scatter(range(len(values_list)), values_list, color='red', label="MAPE Points", zorder=3)  # Scatter plot for individual points

                ax.set_title(f"Delay = {delay} Week ")
                ax.get_legend().remove()

                mape_delay = pd.concat([mape_delay, values_df], axis=1, join='inner')  # Concatenate MAPE results
                mape_wave_delay[waveID] = mape_delay
                #print('waveID ', waveID, 'delay', delay)#, 'mape_delay', mape_delay)
                # Labeling
                if delay == 0:
                    ax.set_ylabel(model_name)
                if delay == len(delay_list) - 1 and model_index == len(models) - 1:
                    ax.legend(
                        ["MAPE", "MAPE", 'First Week', 'Second Week', 'Third Week', 'Fourth Week', 'Fifth Week', 'Sixth Week'],
                        loc='lower center',
                        bbox_to_anchor=(-2, -0.3),
                        ncol=7
                    )

        # Super labels
        fig.supxlabel(f"Prediction Length (Week), Wave = {waveID}")
        fig.supylabel("MAPE %")

    return mape_wave_delay



import matplotlib.pyplot as plt
import datetime
#Visualization.py
def visualize_wave_delays(data_dict):
    """
    Plots clearer and user-friendly time interval ranges for all wave-delay combinations.

    Args:
        data_dict (dict): A dictionary containing wave delay combinations
                          with 'all', 'train', and 'test' data ranges.
    """
    plt.figure(figsize=(14, 8))
    plt.title("Time Interval Comparison for Wave-Delay Combinations", fontsize=16, pad=20)
    plt.xlabel("Date", fontsize=14, labelpad=40)  # Move x-axis label down
    plt.ylabel("Wave-Delay Combinations", fontsize=14, labelpad=15)  # Move y-axis label up

    # Move y-axis label farther to the right
    plt.gca().yaxis.set_label_coords(-0.1, 0.5)  # Adjust x and y positions of label


    y_offset = 1  # Start y_offset for waves
    spacing = 2  # Spacing between each wave

    for wave_name, intervals in data_dict.items():
        # Extract ranges and convert to datetime
        all_range = [datetime.datetime.fromisoformat(i) for i in intervals['all'].index]
        train_range = [datetime.datetime.fromisoformat(i) for i in intervals['train'].index]
        test_range = [datetime.datetime.fromisoformat(i) for i in intervals['test'].index]

        # Plot 'all', 'train', and 'test' ranges with spacing
        plt.hlines(y=y_offset, xmin=all_range[0], xmax=all_range[-1], color='gray', label='Full Range' if y_offset == 1 else "", linewidth=2, alpha=0.7)
        plt.hlines(y=y_offset + 0.5, xmin=train_range[0], xmax=train_range[-1], color='blue', label='Train Range' if y_offset == 1 else "", linewidth=2)
        plt.hlines(y=y_offset + 1, xmin=test_range[0], xmax=test_range[-1], color='green', label='Test Range' if y_offset == 1 else "", linewidth=2)

        # Add markers for start and end dates
        plt.scatter([all_range[0], all_range[-1]], [y_offset, y_offset], color='gray', edgecolor='black', s=40, label='_nolegend_')
        plt.scatter([train_range[0], train_range[-1]], [y_offset + 0.5, y_offset + 0.5], color='blue', edgecolor='black', s=40, label='_nolegend_')
        plt.scatter([test_range[0], test_range[-1]], [y_offset + 1, y_offset + 1], color='green', edgecolor='black', s=40, label='_nolegend_')

        # Annotate wave name slightly to the left
        plt.text(all_range[0] - datetime.timedelta(days=7), y_offset - 0.2, wave_name, fontsize=12, ha='right', color='black')

        # Increment y_offset for the next wave
        y_offset += spacing

    # Adjust y-axis limits
    plt.ylim(0, y_offset)
    plt.yticks([])  # Remove y-axis ticks for a cleaner look
    plt.xticks(rotation=45, fontsize=12)

    # Add a grouped legend
    plt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15), fontsize=12, ncol=3, frameon=False)

    # Final layout adjustments
    plt.tight_layout()
    plt.show()





#generalized

def plot_predictions(wave_tasks, labels, delay, prediction_length, MAPE_data_dictionary, models, observed_label='Observed', recent_week_count=None):
    """
    Generalized function to plot predictions for multiple ML models and ARIMA.

    Parameters:
    - wave_tasks: List of wave task objects
    - delay: Delay parameter
    - prediction_length: Prediction length parameter
    - MAPE_data_dictionary: Dictionary containing MAPE data for each wave, delay, and prediction length
    - models: Dictionary of models to include in the plot
    - observed_label: Column name for the observed data
    - recent_week_count: Optional. Number of weeks to consider for plotting. Defaults to None (all data).
    """
    fig = plt.figure(figsize=(16, 10))
    plt.subplots_adjust(left=0.1, right=1, top=1, bottom=0.15)
    gs = fig.add_gridspec(len(wave_tasks), 1, hspace=0, wspace=0)
    i = 0

    #labels = ['', " & 2", " & 2 & 1"]  # Example labels for waves
    for wave in wave_tasks:
        waveID = wave.waveID
        wave_delay_prediction_length_key = f'wave {waveID} delay {delay} prediction_length {prediction_length}'
        task = MAPE_data_dictionary[wave_delay_prediction_length_key]

        # Extract recent weeks if specified
        if recent_week_count:
            task = task.tail(recent_week_count).reset_index(drop=True)

        ax = fig.add_subplot(gs[i, 0])

        # Plot each model's predictions
        for model_name in models.keys():
            if model_name in task.columns:
                ax.plot(task.index, task[model_name], label=model_name, linestyle='-', lw=1.5)

        # Plot observed data
        if observed_label in task.columns:
            ax.plot(task.index, task[observed_label], label=observed_label, color='black', linestyle='dotted')

        ax.set_ylabel("Wave "+labels[i], fontsize=13)

        i += 1
        if i >= 2:
            ax.legend(loc='lower center', bbox_to_anchor=(1.05, 1), ncol=1)
            ax.set_xticklabels(task.index, rotation=45)

        ax.axvline('2023-10-08', color='black', linestyle='--', lw=2)  # Example date for a vertical line

    # Adding title and labels
    fig.supxlabel('Week', fontsize=16)
    fig.supylabel("Covid Cases", fontsize=16)
    plt.show()

def plot_weekly_predictions(weekly_prediction_future, models, delay, length):
    """
    Plots weekly predictions from different models for a specified delay and length.

    Parameters:
    - weekly_prediction_future (dict): Dictionary containing weekly predictions.
    - models (dict): Dictionary mapping model names to their implementations.
    - delay (int): The delay value to filter the data.
    - length (float): The length value to filter the data.
    """

    # Extract weeks (keys) and model predictions (values)
    weeks = list(weekly_prediction_future.keys())

    # Initialize an empty dictionary to store model predictions
    model_predictions = {model: [] for model in ['Observed', 'ARIMA', 'MLAMA'] + list(models.keys())}
    filtered_weeks = []

    # Loop through each week and extract the predictions
    for week in weeks:
        data = weekly_prediction_future[week]

        # Filter based on delay and length

        # if data['Delay'][0] != delay or data['Length'][0] != length:
        #     continue  # Skip weeks that do not match criteria
        data_filtered = data[(data['Delay']==0) & (data['Length']==1)]
        filtered_weeks.append(week)
        #print(week, filtered_weeks)
        # Extract observed values
        model_predictions['Observed'].append(data_filtered['Observed'] if 'Observed' in data_filtered else None)

        # Extract model predictions
        model_predictions['ARIMA'].append(data_filtered['ARIMA'][0].iloc[0] if 'ARIMA' in data_filtered else None)
        model_predictions['MLAMA'].append(data_filtered['MLAMA'][0].iloc[0] if 'MLAMA' in data_filtered else None)

        for model in models.keys():
            if model == 'ARIMA':
                continue
            model_predictions[model].append(data_filtered[model][0][0] if model in data_filtered else None)

    # Convert week labels to datetime for proper plotting
    week_dates = pd.to_datetime(filtered_weeks)

    # Plot the data
    plt.figure(figsize=(12, 6))

    # Plot each model's predictions
    for model, values in model_predictions.items():
        plt.plot(week_dates, values, marker='o', label=model)

    plt.xlabel("Week")
    plt.ylabel("Predicted Value")
    plt.title(f"Weekly Predictions for Delay={delay}, Length={length}")
    plt.legend()
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.show()

def plot_weekly_evaluation(weekly_prediction_future, models, delay, length, evaluation_metric_suffix):
    """
    Plots weekly evaluation metrics (e.g., MAPE or MSE) from different models for a specified delay and length.

    Parameters:
    - weekly_prediction_future (dict): Dictionary containing weekly evaluation metrics.
    - models (dict): Dictionary mapping model names to their implementations.
    - delay (int): The delay value to filter the data.
    - length (float): The length value to filter the data.
    - evaluation_metric_suffix (str): The suffix for the evaluation metric (e.g., "_MAPE" or "_MSE").
    """

    print('delay:', delay, 'prediction_length:', length)

    # Extract weeks (keys)
    weeks = list(weekly_prediction_future.keys())

    # Initialize dictionary to store evaluation metrics for each model
    model_evaluation = {model + evaluation_metric_suffix: [] for model in ['MLAMA', 'ARIMA'] + list(models.keys())}

    filtered_weeks = []

    # Loop through each week and extract the evaluation metrics
    for week in weeks:
        data = weekly_prediction_future.get(week)  # Get week's data safely
        if data is None:
            continue  # Skip if there's no data

        # Apply filtering based on Delay and Length
        data_filtered = data[(data['Delay'] == delay) & (data['Length'] == length)]

        if data_filtered.empty:
            continue  # Skip if no matching data

        filtered_weeks.append(week)  # Store filtered week

        # Extract and store evaluation metrics for each model
        for model in model_evaluation.keys():
            if model in data_filtered:
                value = data_filtered[model].iloc[0]  # Extract first row's value safely
                if isinstance(value, list):
                    value = value[0]  # Extract from list if it's inside a list
                model_evaluation[model].append(value)
            else:
                model_evaluation[model].append(None)  # Fill missing values with None

    # Convert week labels to datetime for proper plotting
    week_dates = pd.to_datetime(filtered_weeks)

    # Plot the data
    plt.figure(figsize=(12, 6))

    # Plot each model's evaluation metric
    for model, values in model_evaluation.items():
        plt.plot(week_dates, values, marker='o', label=model)

    plt.xlabel("Week")
    plt.ylabel(f"Evaluation Metric {evaluation_metric_suffix}")
    plt.title(f"Weekly Evaluation for Delay={delay}, Length={length}")
    plt.legend()
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.show()

def plot_responsiveness_vs_metric(theDD, metric_name):
  # Filter only metric data for plotting
  theDD_metric = theDD[theDD['Metric'] == metric_name]
  # P1 Plot 1: Adaptability vs MAPE
  plt.figure(figsize=(10, 6))
  sns.lineplot(data=theDD_metric, x='Adaptability', y='Value', hue='Algorithm', linewidth=2.0)
  plt.ylabel('S'+metric_name)
  plt.xlabel('Adaptability/Delay is x-axis. Delayed train+test, how many additional weeks are added for training,  \n'
            'so testing starts from later point in time, test size depends on prediction_length,\n'
            'for all the waves and prediction length averaged to calculate MAPE. \n'
            'Number of Weeks of Data Since the Local Min/Max')
  plt.title('a. Responsiveness')
  plt.show()

def plot_prediction_length_vs_metric(theD_long, metric_name):
  # Filter only metric data for plotting
  # theDD_metric = theDD[theDD['Metric'] == metric_name]
  # Group data by Prediction Length for MAPE
  suffix = '_'+metric_name
  theDD_metric_length = theD_long[theD_long['Algorithm'].str.endswith(suffix)].copy()
  theDD_metric_length['Algorithm'] = theDD_metric_length['Algorithm'].str.replace(suffix, '', regex=False)
  theDD_metric_length = theDD_metric_length.groupby(['Algorithm', 'Prediction Length']).agg({'Value': 'mean'}).reset_index()

  # P2 Plot 2: Prediction Length vs MAPE
  plt.figure(figsize=(10, 6))
  sns.lineplot(data=theDD_metric_length, x='Prediction Length', y='Value', hue='Algorithm', linewidth=2.0)
  plt.ylabel('SMAPE')
  plt.xlabel('Number of Weeks in Forecast, averaged for all delay, wave')
  plt.title('b. Prediction Length')
  plt.show()