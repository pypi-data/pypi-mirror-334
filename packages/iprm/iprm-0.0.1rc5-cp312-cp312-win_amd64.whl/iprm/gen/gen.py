import os
import sys
import subprocess
from pathlib import Path
from abc import ABC, abstractmethod
from iprm.load.load import Loader
from iprm.util.env import Env
from iprm.util.vcvarsall import vcvarsall_script
from iprm.core.object import Object
from iprm.api.obj.project import Project
from iprm.api.obj.subdirectories import SubDirectories
from iprm.api.obj.cxx import CXXTarget
from iprm.api.obj.rust import RustTarget

iprm_gen_dir_path = os.path.dirname(__file__)
src_dir_path = os.path.abspath(os.path.join(iprm_gen_dir_path, '..', '..'))
sys.path.append(src_dir_path)
from iprm.util.vcvarsall import find_vcvarsall


class Generator(ABC):
    def __init__(self, loader: Loader, **kwargs):
        self._loader = loader
        # TODO: Use this for something
        self._config = kwargs

    @property
    @abstractmethod
    def generated_file_name(self):
        pass

    @property
    @abstractmethod
    def release_build_type(self):
        pass

    @property
    def loader(self):
        return self._loader

    @property
    def project_dir_str(self):
        return str(self.loader.project_dir)

    def generate_project(self):
        project_objects = self.loader.load_project()
        num_files_to_generate = len(project_objects.keys()) if project_objects is not None else 0
        if num_files_to_generate == 0:
            self.loader.log_sink.log_message(f'{self.loader.file_name()}: no CMakeLists.txt files to generate')
            return

        sorted_project_file_objects = {}
        for native_file_path, objects in project_objects.items():
            # TODO: properly sort objects based on generation requirements (although we may not need it anymore if
            #  the API re-write structured in such a way that each object has all the context it needs. This is the
            #  ideal/goal for drastic simplifications
            # sorted_project_file_objects[native_file_path] = sorted(objects, key=self._order_key)
            sorted_project_file_objects[native_file_path] = objects

        # Ensure we process all the files with frameworks first, so we can set up any global state
        # required by targets that depend on the framework. In handwritten CMake you can set things
        # up such that variables/data is set before anyone depends on it, but we don't have that luxury
        sorted_project_file_paths = sorted(sorted_project_file_objects.keys(),
                                           key=lambda k: not any(
                                               proj_file_obj.is_framework for proj_file_obj in
                                               sorted_project_file_objects[k]))

        num_files_generated = 1
        for project_file_path in sorted_project_file_paths:
            def gen_log():
                self.loader.log_sink.log_message(
                    f'[{num_files_generated}/{num_files_to_generate}] Generating {self.generated_file_name} from '
                    f'{project_file_path}', end='\r')

            gen_log()

            objects = sorted_project_file_objects[project_file_path]

            from iprm import __version__
            from datetime import datetime, timezone
            generated_content = [
                '# =========================================================',
                '# WARNING: This file is auto-generated. DO NOT EDIT MANUALLY',
                f'# Generated by: iprm (v{__version__})',
                f'# Generated on: {datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S %Z")}',
                f'# Platform: {Env.platform.display_name()}',
                '# =========================================================',
            ]
            for obj in objects:
                # NOTE: Generators are state-less, it assumes validation on the native objects has happened by this
                # point and just spits out what the object tells it to. Actual validation on the generated files can
                # be tested by running the various configure, build, test, and install commands to target project model
                # supports and independently verifying the results are what one expects
                generated_obj_content = self._generate_object(obj)
                if generated_obj_content:
                    generated_content.extend(generated_obj_content)
                else:
                    # TODO: log saying no content for the object was generated
                    pass

            generated_file_path = Path(str(project_file_path)).parent / self.generated_file_name
            with open(generated_file_path, 'w') as file:
                file.write('\n'.join(generated_content))
                num_files_generated += 1
        self.loader.log_sink.log_message('')

    @classmethod
    def _generate_object(cls, obj: Object) -> list[str]:
        from typing import cast
        if obj.is_project:
            project = cast(Project, obj)
            return cls._generate_project(project)
        elif obj.is_subdirs:
            subdirs = cast(SubDirectories, obj)
            return cls._generate_subdirectories(subdirs)
        elif obj.is_cxx:
            cxx = cast(CXXTarget, obj)
            return cls._generate_cxx(cxx)
        elif obj.is_rust:
            rust = cast(RustTarget, obj)
            return cls._generate_rust(rust)
        return []

    @classmethod
    @abstractmethod
    def _generate_project(cls, project: Project) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_subdirectories(cls, subdirs: SubDirectories) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_cxx(cls, cxx: CXXTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_rust(cls, rust: RustTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def current_src_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def current_bin_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def configure(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def build(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def test(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def install(cls, **kwargs):
        pass

    @classmethod
    def _num_procs(cls):
        if Env.platform.windows:
            return '%NUMBER_OF_PROCESSORS%'
        elif Env.platform.macos:
            return '$(sysctl -n hw.ncpu)'
        elif Env.platform.linux:
            return '$(nproc)'
        return None

    @classmethod
    def _run_command(cls, cmd):
        cmd_str = ' '.join(cmd)
        return subprocess.run(
            vcvarsall_script(cmd_str) if Env.platform.windows else cmd_str, shell=True).returncode
