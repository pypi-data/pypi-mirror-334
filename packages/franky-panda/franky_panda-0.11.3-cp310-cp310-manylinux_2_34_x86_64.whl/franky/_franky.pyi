"""
High-Level Motion Library for the Franka Panda Robot
"""
from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
__all__ = ['Affine', 'BoolFuture', 'CartesianImpedanceMotion', 'CartesianMotion', 'CartesianPose', 'CartesianPoseMotion', 'CartesianPoseReaction', 'CartesianPoseStopMotion', 'CartesianState', 'CartesianVelocities', 'CartesianVelocityMotion', 'CartesianVelocityReaction', 'CartesianWaypoint', 'CartesianWaypointMotion', 'CommandException', 'Condition', 'ControlException', 'ControlSignalType', 'ControllerMode', 'Duration', 'Errors', 'Exception', 'ExponentialImpedanceMotion', 'Gripper', 'GripperException', 'GripperState', 'ImpedanceMotion', 'IncompatibleVersionException', 'InvalidMotionTypeException', 'InvalidOperationException', 'JointMotion', 'JointPositionMotion', 'JointPositionReaction', 'JointPositionStopMotion', 'JointPositions', 'JointState', 'JointVelocities', 'JointVelocityMotion', 'JointVelocityReaction', 'JointWaypoint', 'JointWaypointMotion', 'Kinematics', 'LinearMotion', 'Measure', 'ModelException', 'NetworkException', 'NullSpaceHandling', 'ProtocolException', 'ReactionRecursionException', 'RealtimeConfig', 'RealtimeException', 'ReferenceType', 'RelativeDynamicsFactor', 'RobotInternal', 'RobotMode', 'RobotPose', 'RobotState', 'RobotVelocity', 'TorqueMotion', 'TorqueReaction', 'Torques', 'Twist']
class Affine:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, transformation_matrix: numpy.ndarray[numpy.float64[4, 4]] = ...) -> None:
        ...
    @typing.overload
    def __init__(self, translation: numpy.ndarray[numpy.float64[3, 1]] = ..., quaternion: numpy.ndarray[numpy.float64[4, 1]] = ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Affine) -> None:
        ...
    def __mul__(self, arg0: Affine) -> Affine:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def inverse(self) -> Affine:
        ...
    @property
    def matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    @property
    def quaternion(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    @property
    def translation(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class BoolFuture:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def get(self) -> bool:
        ...
    def wait(self, timeout: float | None = None) -> bool:
        ...
class CartesianImpedanceMotion(ImpedanceMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, target: Affine, duration: float, target_type: ReferenceType = ..., translational_stiffness: float = 2000, rotational_stiffness: float = 200, force_constraints: typing.Annotated[list[float | None], pybind11_stubgen.typing_ext.FixedSize(6)] | None = None, return_when_finished: bool = True, finish_wait_factor: float = 1.2) -> None:
        ...
class CartesianMotion(CartesianWaypointMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, target: CartesianState | RobotPose | Affine, reference_type: ReferenceType = ..., frame: Affine | None = None, relative_dynamics_factor: RelativeDynamicsFactor | float = 1.0, return_when_finished: bool = True) -> None:
        ...
class CartesianPose:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def O_T_EE(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
class CartesianPoseMotion:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def add_reaction(self, arg0: CartesianPoseReaction) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, _franky.Duration, float, float, _franky.CartesianPose], None]) -> None:
        ...
    @property
    def reactions(self) -> list[CartesianPoseReaction]:
        ...
class CartesianPoseReaction:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, condition: Condition | bool, motion: CartesianPoseMotion = None) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, float, float], None]) -> None:
        ...
class CartesianPoseStopMotion(CartesianPoseMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self) -> None:
        ...
class CartesianState:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, pose: RobotPose | Affine) -> None:
        ...
    @typing.overload
    def __init__(self, pose: RobotPose | Affine, velocity: RobotVelocity | Twist) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianState | RobotPose | Affine) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: Affine) -> CartesianState:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def change_end_effector_frame(self, transform: Affine) -> CartesianState:
        ...
    def transform_with(self, transform: Affine) -> CartesianState:
        ...
    @property
    def pose(self) -> RobotPose:
        ...
    @property
    def velocity(self) -> RobotVelocity:
        ...
class CartesianVelocities:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def O_dP_EE(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
class CartesianVelocityMotion:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def add_reaction(self, arg0: CartesianVelocityReaction) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, _franky.Duration, float, float, _franky.CartesianVelocities], None]) -> None:
        ...
    @property
    def reactions(self) -> list[CartesianVelocityReaction]:
        ...
class CartesianVelocityReaction:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, condition: Condition | bool, motion: CartesianVelocityMotion = None) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, float, float], None]) -> None:
        ...
class CartesianWaypoint:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, target: CartesianState | RobotPose | Affine, reference_type: ReferenceType = ..., relative_dynamics_factor: RelativeDynamicsFactor | float = 1.0, minimum_time: float | None = None) -> None:
        ...
    @property
    def minimum_time(self) -> float | None:
        ...
    @property
    def reference_type(self) -> ReferenceType:
        ...
    @property
    def relative_dynamics_factor(self) -> RelativeDynamicsFactor:
        ...
    @property
    def target(self) -> CartesianState:
        ...
class CartesianWaypointMotion(CartesianPoseMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, waypoints: list[CartesianWaypoint], frame: Affine | None = None, relative_dynamics_factor: RelativeDynamicsFactor | float = 1.0, return_when_finished: bool = True) -> None:
        ...
class CommandException(Exception):
    pass
class Condition:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __and__(self, arg0: Condition | bool) -> Condition:
        ...
    @typing.overload
    def __and__(self, arg0: bool) -> Condition:
        ...
    @typing.overload
    def __eq__(self, arg0: Condition | bool) -> Condition:
        ...
    @typing.overload
    def __eq__(self, arg0: bool) -> Condition:
        ...
    def __init__(self, constant_value: bool) -> None:
        ...
    def __invert__(self) -> Condition:
        ...
    @typing.overload
    def __ne__(self, arg0: Condition | bool) -> Condition:
        ...
    @typing.overload
    def __ne__(self, arg0: bool) -> Condition:
        ...
    @typing.overload
    def __or__(self, arg0: Condition | bool) -> Condition:
        ...
    @typing.overload
    def __or__(self, arg0: bool) -> Condition:
        ...
    def __rand__(self, arg0: Condition | bool) -> Condition:
        ...
    def __repr__(self) -> str:
        ...
    def __ror__(self, arg0: Condition | bool) -> Condition:
        ...
class ControlException(Exception):
    pass
class ControlSignalType:
    """
    Members:
    
      Torques
    
      JointVelocities
    
      JointPositions
    
      CartesianVelocities
    
      CartesianPose
    """
    CartesianPose: typing.ClassVar[ControlSignalType]  # value = <ControlSignalType.CartesianPose: 4>
    CartesianVelocities: typing.ClassVar[ControlSignalType]  # value = <ControlSignalType.CartesianVelocities: 3>
    JointPositions: typing.ClassVar[ControlSignalType]  # value = <ControlSignalType.JointPositions: 2>
    JointVelocities: typing.ClassVar[ControlSignalType]  # value = <ControlSignalType.JointVelocities: 1>
    Torques: typing.ClassVar[ControlSignalType]  # value = <ControlSignalType.Torques: 0>
    __members__: typing.ClassVar[dict[str, ControlSignalType]]  # value = {'Torques': <ControlSignalType.Torques: 0>, 'JointVelocities': <ControlSignalType.JointVelocities: 1>, 'JointPositions': <ControlSignalType.JointPositions: 2>, 'CartesianVelocities': <ControlSignalType.CartesianVelocities: 3>, 'CartesianPose': <ControlSignalType.CartesianPose: 4>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ControllerMode:
    """
    Members:
    
      JointImpedance
    
      CartesianImpedance
    """
    CartesianImpedance: typing.ClassVar[ControllerMode]  # value = <ControllerMode.CartesianImpedance: 1>
    JointImpedance: typing.ClassVar[ControllerMode]  # value = <ControllerMode.JointImpedance: 0>
    __members__: typing.ClassVar[dict[str, ControllerMode]]  # value = {'JointImpedance': <ControllerMode.JointImpedance: 0>, 'CartesianImpedance': <ControllerMode.CartesianImpedance: 1>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Duration:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __add__(self, arg0: Duration) -> Duration:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __iadd__(self, arg0: Duration) -> Duration:
        ...
    def __imul__(self, arg0: int) -> Duration:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def __isub__(self, arg0: Duration) -> Duration:
        ...
    def __itruediv__(self, arg0: int) -> Duration:
        ...
    def __mul__(self, arg0: int) -> Duration:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __sub__(self, arg0: Duration) -> Duration:
        ...
    def __truediv__(self, arg0: int) -> Duration:
        ...
    def to_msec(self) -> int:
        ...
    def to_sec(self) -> float:
        ...
class Errors:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def base_acceleration_initialization_timeout(self) -> bool:
        ...
    @property
    def base_acceleration_invalid_reading(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_acceleration_discontinuity(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_elbow_limit_violation(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_elbow_sign_inconsistent(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_joint_acceleration_discontinuity(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_joint_position_limits_violation(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_joint_velocity_discontinuity(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_joint_velocity_limits_violation(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_start_elbow_invalid(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_velocity_discontinuity(self) -> bool:
        ...
    @property
    def cartesian_motion_generator_velocity_limits_violation(self) -> bool:
        ...
    @property
    def cartesian_position_limits_violation(self) -> bool:
        ...
    @property
    def cartesian_position_motion_generator_invalid_frame(self) -> bool:
        ...
    @property
    def cartesian_position_motion_generator_start_pose_invalid(self) -> bool:
        ...
    @property
    def cartesian_reflex(self) -> bool:
        ...
    @property
    def cartesian_spline_motion_generator_violation(self) -> bool:
        ...
    @property
    def cartesian_velocity_profile_safety_violation(self) -> bool:
        ...
    @property
    def cartesian_velocity_violation(self) -> bool:
        ...
    @property
    def communication_constraints_violation(self) -> bool:
        ...
    @property
    def controller_torque_discontinuity(self) -> bool:
        ...
    @property
    def force_control_safety_violation(self) -> bool:
        ...
    @property
    def force_controller_desired_force_tolerance_violation(self) -> bool:
        ...
    @property
    def instability_detected(self) -> bool:
        ...
    @property
    def joint_motion_generator_acceleration_discontinuity(self) -> bool:
        ...
    @property
    def joint_motion_generator_position_limits_violation(self) -> bool:
        ...
    @property
    def joint_motion_generator_velocity_discontinuity(self) -> bool:
        ...
    @property
    def joint_motion_generator_velocity_limits_violation(self) -> bool:
        ...
    @property
    def joint_move_in_wrong_direction(self) -> bool:
        ...
    @property
    def joint_p2p_insufficient_torque_for_planning(self) -> bool:
        ...
    @property
    def joint_position_limits_violation(self) -> bool:
        ...
    @property
    def joint_position_motion_generator_start_pose_invalid(self) -> bool:
        ...
    @property
    def joint_reflex(self) -> bool:
        ...
    @property
    def joint_velocity_violation(self) -> bool:
        ...
    @property
    def joint_via_motion_generator_planning_joint_limit_violation(self) -> bool:
        ...
    @property
    def max_goal_pose_deviation_violation(self) -> bool:
        ...
    @property
    def max_path_pose_deviation_violation(self) -> bool:
        ...
    @property
    def power_limit_violation(self) -> bool:
        ...
    @property
    def self_collision_avoidance_violation(self) -> bool:
        ...
    @property
    def start_elbow_sign_inconsistent(self) -> bool:
        ...
    @property
    def tau_j_range_violation(self) -> bool:
        ...
class Exception(Exception):
    pass
class ExponentialImpedanceMotion(ImpedanceMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, target: Affine, target_type: ReferenceType = ..., translational_stiffness: float = 2000, rotational_stiffness: float = 200, force_constraints: typing.Annotated[list[float | None], pybind11_stubgen.typing_ext.FixedSize(6)] | None = None, exponential_decay: float = 0.005) -> None:
        ...
class Gripper:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, fci_hostname: str) -> None:
        ...
    def grasp(self, width: float, speed: float, force: float, epsilon_inner: float = 0.005, epsilon_outer: float = 0.005) -> bool:
        ...
    def grasp_async(self, width: float, speed: float, force: float, epsilon_inner: float = 0.005, epsilon_outer: float = 0.005) -> ...:
        ...
    def homing(self) -> bool:
        ...
    def homing_async(self) -> ...:
        ...
    def move(self, width: float, speed: float) -> bool:
        ...
    def move_async(self, width: float, speed: float) -> ...:
        ...
    def open(self, speed: float) -> bool:
        ...
    def open_async(self, speed: float) -> ...:
        ...
    def stop(self) -> bool:
        ...
    def stop_async(self) -> ...:
        ...
    @property
    def is_grasped(self) -> bool:
        ...
    @property
    def max_width(self) -> float:
        ...
    @property
    def server_version(self) -> int:
        ...
    @property
    def state(self) -> GripperState:
        ...
    @property
    def width(self) -> float:
        ...
class GripperException(Exception):
    pass
class GripperState:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def is_grasped(self) -> bool:
        ...
    @property
    def max_width(self) -> float:
        ...
    @property
    def temperature(self) -> int:
        ...
    @property
    def time(self) -> Duration:
        ...
    @property
    def width(self) -> float:
        ...
class ImpedanceMotion(TorqueMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
class IncompatibleVersionException(Exception):
    pass
class InvalidMotionTypeException(Exception):
    pass
class InvalidOperationException(Exception):
    pass
class JointMotion(JointWaypointMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, target: JointState | list[float] | np.ndarray, reference_type: ReferenceType = ..., relative_dynamics_factor: float = 1.0, return_when_finished: bool = True) -> None:
        ...
class JointPositionMotion:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def add_reaction(self, arg0: JointPositionReaction) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, _franky.Duration, float, float, _franky.JointPositions], None]) -> None:
        ...
    @property
    def reactions(self) -> list[JointPositionReaction]:
        ...
class JointPositionReaction:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, condition: Condition | bool, motion: JointPositionMotion = None) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, float, float], None]) -> None:
        ...
class JointPositionStopMotion(JointPositionMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self) -> None:
        ...
class JointPositions:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def q(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
class JointState:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, position: numpy.ndarray[numpy.float64[7, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, position: numpy.ndarray[numpy.float64[7, 1]], velocity: numpy.ndarray[numpy.float64[7, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JointState | list[float] | np.ndarray) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def position(self) -> numpy.ndarray[numpy.float64[7, 1]]:
        ...
    @property
    def velocity(self) -> numpy.ndarray[numpy.float64[7, 1]]:
        ...
class JointVelocities:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def dq(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
class JointVelocityMotion:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def add_reaction(self, arg0: JointVelocityReaction) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, _franky.Duration, float, float, _franky.JointVelocities], None]) -> None:
        ...
    @property
    def reactions(self) -> list[JointVelocityReaction]:
        ...
class JointVelocityReaction:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, condition: Condition | bool, motion: JointVelocityMotion = None) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, float, float], None]) -> None:
        ...
class JointWaypoint:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, target: JointState | list[float] | np.ndarray, reference_type: ReferenceType = ..., relative_dynamics_factor: RelativeDynamicsFactor | float = 1.0, minimum_time: float | None = None) -> None:
        ...
    @property
    def minimum_time(self) -> float | None:
        ...
    @property
    def reference_type(self) -> ReferenceType:
        ...
    @property
    def relative_dynamics_factor(self) -> RelativeDynamicsFactor:
        ...
    @property
    def target(self) -> JointState:
        ...
class JointWaypointMotion(JointPositionMotion):
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, waypoints: list[JointWaypoint], relative_dynamics_factor: RelativeDynamicsFactor | float = 1.0, return_when_finished: bool = True) -> None:
        ...
class Kinematics:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    def forward(q: numpy.ndarray[numpy.float64[7, 1]]) -> Affine:
        ...
    @staticmethod
    def forward_elbow(q: numpy.ndarray[numpy.float64[7, 1]]) -> Affine:
        ...
    @staticmethod
    def forward_euler(q: numpy.ndarray[numpy.float64[7, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    def jacobian(q: numpy.ndarray[numpy.float64[7, 1]]) -> numpy.ndarray[numpy.float64[6, 7]]:
        ...
class Measure:
    ABS_TIME: typing.ClassVar[Measure]  # value = t
    FORCE_X: typing.ClassVar[Measure]  # value = F_x
    FORCE_Y: typing.ClassVar[Measure]  # value = F_y
    FORCE_Z: typing.ClassVar[Measure]  # value = F_z
    REL_TIME: typing.ClassVar[Measure]  # value = t
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __add__(self, arg0: Measure) -> Measure:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> Measure:
        ...
    @typing.overload
    def __eq__(self, arg0: Measure) -> Condition:
        ...
    @typing.overload
    def __eq__(self, arg0: float) -> Condition:
        ...
    @typing.overload
    def __ge__(self, arg0: Measure) -> Condition:
        ...
    @typing.overload
    def __ge__(self, arg0: float) -> Condition:
        ...
    @typing.overload
    def __gt__(self, arg0: Measure) -> Condition:
        ...
    @typing.overload
    def __gt__(self, arg0: float) -> Condition:
        ...
    @typing.overload
    def __le__(self, arg0: Measure) -> Condition:
        ...
    @typing.overload
    def __le__(self, arg0: float) -> Condition:
        ...
    @typing.overload
    def __lt__(self, arg0: Measure) -> Condition:
        ...
    @typing.overload
    def __lt__(self, arg0: float) -> Condition:
        ...
    @typing.overload
    def __mul__(self, arg0: Measure) -> Measure:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Measure:
        ...
    @typing.overload
    def __ne__(self, arg0: Measure) -> Condition:
        ...
    @typing.overload
    def __ne__(self, arg0: float) -> Condition:
        ...
    def __neg__(self) -> Measure:
        ...
    @typing.overload
    def __pow__(self, arg0: Measure) -> Measure:
        ...
    @typing.overload
    def __pow__(self, arg0: float) -> Measure:
        ...
    def __radd__(self, arg0: float) -> Measure:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Measure:
        ...
    def __rpow__(self, arg0: float) -> Measure:
        ...
    def __rsub__(self, arg0: float) -> Measure:
        ...
    def __rtruediv__(self, arg0: float) -> Measure:
        ...
    @typing.overload
    def __sub__(self, arg0: Measure) -> Measure:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> Measure:
        ...
    @typing.overload
    def __truediv__(self, arg0: Measure) -> Measure:
        ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Measure:
        ...
class ModelException(Exception):
    pass
class NetworkException(Exception):
    pass
class NullSpaceHandling:
    joint_index: int
    value: float
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, joint_index: int, value: float) -> None:
        ...
class ProtocolException(Exception):
    pass
class ReactionRecursionException(Exception):
    pass
class RealtimeConfig:
    """
    Members:
    
      Enforce
    
      Ignore
    """
    Enforce: typing.ClassVar[RealtimeConfig]  # value = <RealtimeConfig.Enforce: 0>
    Ignore: typing.ClassVar[RealtimeConfig]  # value = <RealtimeConfig.Ignore: 1>
    __members__: typing.ClassVar[dict[str, RealtimeConfig]]  # value = {'Enforce': <RealtimeConfig.Enforce: 0>, 'Ignore': <RealtimeConfig.Ignore: 1>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RealtimeException(Exception):
    pass
class ReferenceType:
    """
    Members:
    
      Relative
    
      Absolute
    """
    Absolute: typing.ClassVar[ReferenceType]  # value = <ReferenceType.Absolute: 0>
    Relative: typing.ClassVar[ReferenceType]  # value = <ReferenceType.Relative: 1>
    __members__: typing.ClassVar[dict[str, ReferenceType]]  # value = {'Relative': <ReferenceType.Relative: 1>, 'Absolute': <ReferenceType.Absolute: 0>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RelativeDynamicsFactor:
    MAX_DYNAMICS: typing.ClassVar[RelativeDynamicsFactor]  # value = <_franky.RelativeDynamicsFactor object>
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, value: float) -> None:
        ...
    @typing.overload
    def __init__(self, velocity: float, acceleration: float, jerk: float) -> None:
        ...
    def __mul__(self, arg0: RelativeDynamicsFactor | float) -> RelativeDynamicsFactor:
        ...
    @property
    def acceleration(self) -> float:
        ...
    @property
    def jerk(self) -> float:
        ...
    @property
    def max_dynamics(self) -> bool:
        ...
    @property
    def velocity(self) -> float:
        ...
class RobotInternal:
    control_rate: typing.ClassVar[float] = 0.001
    degrees_of_freedom: typing.ClassVar[int] = 7
    max_elbow_acceleration: typing.ClassVar[float] = 10.0
    max_elbow_jerk: typing.ClassVar[float] = 5000.0
    max_elbow_velocity: typing.ClassVar[float] = 2.175
    max_joint_acceleration: typing.ClassVar[numpy.ndarray]  # value = array([15. ,  7.5, 10. , 12.5, 15. , 20. , 20. ])
    max_joint_jerk: typing.ClassVar[numpy.ndarray]  # value = array([ 7500.,  3750.,  5000.,  6250.,  7500., 10000., 10000.])
    max_joint_velocity: typing.ClassVar[numpy.ndarray]  # value = array([2.175, 2.175, 2.175, 2.175, 2.61 , 2.61 , 2.61 ])
    max_rotation_acceleration: typing.ClassVar[float] = 25.0
    max_rotation_jerk: typing.ClassVar[float] = 12500.0
    max_rotation_velocity: typing.ClassVar[float] = 2.5
    max_translation_acceleration: typing.ClassVar[float] = 13.0
    max_translation_jerk: typing.ClassVar[float] = 6500.0
    max_translation_velocity: typing.ClassVar[float] = 1.7
    relative_dynamics_factor: RelativeDynamicsFactor
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    def forward_kinematics(q: numpy.ndarray[numpy.float64[7, 1]]) -> Affine:
        ...
    def __init__(self, fci_hostname: str, relative_dynamics_factor: RelativeDynamicsFactor | float = 1.0, default_torque_threshold: float = 20.0, default_force_threshold: float = 30.0, controller_mode: ControllerMode = ..., realtime_config: RealtimeConfig = ...) -> None:
        ...
    def join_motion(self, timeout: float | None = None) -> bool:
        ...
    @typing.overload
    def move(self, motion: CartesianPoseMotion, asynchronous: bool = False) -> None:
        ...
    @typing.overload
    def move(self, motion: CartesianVelocityMotion, asynchronous: bool = False) -> None:
        ...
    @typing.overload
    def move(self, motion: JointPositionMotion, asynchronous: bool = False) -> None:
        ...
    @typing.overload
    def move(self, motion: JointVelocityMotion, asynchronous: bool = False) -> None:
        ...
    @typing.overload
    def move(self, motion: TorqueMotion, asynchronous: bool = False) -> None:
        ...
    def poll_motion(self) -> bool:
        ...
    def recover_from_errors(self) -> bool:
        ...
    def set_cartesian_impedance(self, K_x: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]) -> None:
        ...
    @typing.overload
    def set_collision_behavior(self, torque_thresholds: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], force_thresholds: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def set_collision_behavior(self, lower_torque_threshold: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], upper_torque_threshold: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], lower_force_threshold: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]], upper_force_threshold: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    @typing.overload
    def set_collision_behavior(self, lower_torque_threshold_acceleration: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], upper_torque_threshold_acceleration: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], lower_torque_threshold_nominal: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], upper_torque_threshold_nominal: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)] | numpy.ndarray[numpy.float64[7, 1]], lower_force_threshold_acceleration: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]], upper_force_threshold_acceleration: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]], lower_force_threshold_nominal: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]], upper_force_threshold_nominal: float | typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)] | numpy.ndarray[numpy.float64[6, 1]]) -> None:
        ...
    def set_ee(self, NE_T_EE: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]) -> None:
        ...
    def set_guiding_mode(self, guiding_mode: typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(6)], elbow: bool) -> None:
        ...
    def set_joint_impedance(self, K_theta: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]) -> None:
        ...
    def set_k(self, EE_T_K: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]) -> None:
        ...
    def set_load(self, load_mass: float, F_x_Cload: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)], load_inertia: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(9)]) -> None:
        ...
    def stop(self) -> None:
        ...
    @property
    def current_cartesian_state(self) -> CartesianState:
        ...
    @property
    def current_cartesian_velocity(self) -> RobotVelocity:
        ...
    @property
    def current_control_signal_type(self) -> ControlSignalType | None:
        ...
    @property
    def current_joint_positions(self) -> numpy.ndarray[numpy.float64[7, 1]]:
        ...
    @property
    def current_joint_state(self) -> JointState:
        ...
    @property
    def current_joint_velocities(self) -> numpy.ndarray[numpy.float64[7, 1]]:
        ...
    @property
    def current_pose(self) -> RobotPose:
        ...
    @property
    def fci_hostname(self) -> str:
        ...
    @property
    def has_errors(self) -> bool:
        ...
    @property
    def is_in_control(self) -> bool:
        ...
    @property
    def state(self) -> RobotState:
        ...
class RobotMode:
    """
    Members:
    
      Other
    
      Idle
    
      Move
    
      Guiding
    
      Reflex
    
      UserStopped
    
      AutomaticErrorRecovery
    """
    AutomaticErrorRecovery: typing.ClassVar[RobotMode]  # value = <RobotMode.AutomaticErrorRecovery: 6>
    Guiding: typing.ClassVar[RobotMode]  # value = <RobotMode.Guiding: 3>
    Idle: typing.ClassVar[RobotMode]  # value = <RobotMode.Idle: 1>
    Move: typing.ClassVar[RobotMode]  # value = <RobotMode.Move: 2>
    Other: typing.ClassVar[RobotMode]  # value = <RobotMode.Other: 0>
    Reflex: typing.ClassVar[RobotMode]  # value = <RobotMode.Reflex: 4>
    UserStopped: typing.ClassVar[RobotMode]  # value = <RobotMode.UserStopped: 5>
    __members__: typing.ClassVar[dict[str, RobotMode]]  # value = {'Other': <RobotMode.Other: 0>, 'Idle': <RobotMode.Idle: 1>, 'Move': <RobotMode.Move: 2>, 'Guiding': <RobotMode.Guiding: 3>, 'Reflex': <RobotMode.Reflex: 4>, 'UserStopped': <RobotMode.UserStopped: 5>, 'AutomaticErrorRecovery': <RobotMode.AutomaticErrorRecovery: 6>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class RobotPose:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, end_effector_pose: Affine, elbow_position: float | None = None) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RobotPose | Affine) -> None:
        ...
    def __mul__(self, arg0: Affine) -> RobotPose:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: Affine) -> RobotPose:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def with_elbow_position(self, elbow_position: float | None) -> RobotPose:
        ...
    @property
    def elbow_position(self) -> float | None:
        ...
    @property
    def end_effector_pose(self) -> Affine:
        ...
class RobotState:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def EE_T_K(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def F_T_EE(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def F_T_NE(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def F_x_Cee(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def F_x_Cload(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def F_x_Ctotal(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def I_ee(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    @property
    def I_load(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    @property
    def I_total(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    @property
    def K_F_ext_hat_K(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def NE_T_EE(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def O_F_ext_hat_K(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def O_T_EE(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def O_T_EE_c(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def O_T_EE_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(16)]:
        ...
    @property
    def O_dP_EE_c(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def O_dP_EE_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def O_ddP_EE_c(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def O_ddP_O(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def cartesian_collision(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def cartesian_contact(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    @property
    def control_command_success_rate(self) -> float:
        ...
    @property
    def current_errors(self) -> Errors:
        ...
    @property
    def ddelbow_c(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def ddq_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def delbow_c(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def dq(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def dq_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def dtau_J(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def dtheta(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def elbow(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def elbow_c(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def elbow_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    @property
    def joint_collision(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def joint_contact(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def last_motion_errors(self) -> Errors:
        ...
    @property
    def m_ee(self) -> float:
        ...
    @property
    def m_load(self) -> float:
        ...
    @property
    def m_total(self) -> float:
        ...
    @property
    def q(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def q_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def robot_mode(self) -> RobotMode:
        ...
    @property
    def tau_J(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def tau_J_d(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def tau_ext_hat_filtered(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def theta(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
    @property
    def time(self) -> Duration:
        ...
class RobotVelocity:
    @staticmethod
    @typing.overload
    def __rmul__(*args, **kwargs) -> RobotVelocity:
        ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, end_effector_twist: Twist, elbow_velocity: float = 0.0) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RobotVelocity | Twist) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: Affine) -> RobotVelocity:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def change_end_effector_frame(self, offset_world_frame: numpy.ndarray[numpy.float64[3, 1]]) -> RobotVelocity:
        ...
    @property
    def elbow_velocity(self) -> float | None:
        ...
    @property
    def end_effector_twist(self) -> Twist:
        ...
class TorqueMotion:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def add_reaction(self, arg0: TorqueReaction) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, _franky.Duration, float, float, _franky.Torques], None]) -> None:
        ...
    @property
    def reactions(self) -> list[TorqueReaction]:
        ...
class TorqueReaction:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, condition: Condition | bool, motion: TorqueMotion = None) -> None:
        ...
    def register_callback(self, callback: typing.Callable[[_franky.RobotState, float, float], None]) -> None:
        ...
class Torques:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @property
    def tau_J(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(7)]:
        ...
class Twist:
    @staticmethod
    @typing.overload
    def __rmul__(*args, **kwargs) -> Twist:
        ...
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    @typing.overload
    def transform_with(*args, **kwargs) -> Twist:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, linear_velocity: numpy.ndarray[numpy.float64[3, 1]] | None = None, angular_velocity: numpy.ndarray[numpy.float64[3, 1]] | None = None) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Twist) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: Affine) -> Twist:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def propagate_through_link(self, link_translation: numpy.ndarray[numpy.float64[3, 1]]) -> Twist:
        ...
    @typing.overload
    def transform_with(self, affine: Affine) -> Twist:
        ...
    @property
    def angular(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @property
    def linear(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
LinearMotion = CartesianMotion
