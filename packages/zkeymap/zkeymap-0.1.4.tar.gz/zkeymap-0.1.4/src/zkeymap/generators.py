# Copyright (c) 2025 Frank David Martínez Muñoz <mnesarco>
# SPDX-License-Identifier: MIT

"""
Output file generators.
"""

from __future__ import annotations

from dataclasses import dataclass
import json
from datetime import datetime
from itertools import chain, count
from pathlib import Path
from typing import Any, Callable
import string

from .model import (
    Layer,
    Layout,
    Writer,
    alias,
    ccode,
    devicetree,
    layer,
    layout,
)
from .model import layer as main_layers
from .model import layout as main_layout
from .utils import first


def init_writer(
    output: str | Writer, caller: Callable[[str | Writer], None]
) -> bool:
    """Open output file if required"""
    if isinstance(output, str):
        with Path(output).open("w") as out:
            writer = Writer(out)
            write_header_comment(output, writer)
            caller(writer)
        return False
    return True


def write_header_comment(name: str, writer: Writer) -> None:
    """Generate file header"""
    writer.ln(f"/* Generated by zkeymap: {datetime.now()} {name} */")


def build_macros(output: str | Writer) -> None:
    """Generate devicetree code of all defined macros."""
    if init_writer(output, build_macros):
        for macro in alias.macros:
            macro.render(output)


def build_tap_dances(output: str | Writer) -> None:
    """Generate devicetree code of all defined tap dances."""
    if init_writer(output, build_tap_dances):
        for dance in alias.tap_dances:
            dance.render(output)


def build_rotary_encoders(output: str | Writer) -> None:
    """Generate devicetree code of all defined rotary encoders."""
    if init_writer(output, build_rotary_encoders):
        for enc in alias.rot_encoders:
            enc.render(output)


def build_morphs(writer: Writer) -> None:
    """Generate devicetree code of all defined behavior-mod-morph"""
    for m in alias.morphs:
        if isinstance(m.normal, str):
            base_bindings = " ".join(m.resolve())
        else:
            base_bindings = f"&{m.normal.name}"
        for mods, morph in m.morph.items():
            morph_bindings = f"&{morph.name}"
            if morph.name.endswith("_ucu"):
                name = morph.name.removesuffix("_ucu")
            else:
                name = f"{morph.name}_{mods.key.lower()}"
            writer.ln(
                f"""
                / {{
                    behaviors {{
                        {name}: {name} {{
                            compatible = "zmk,behavior-mod-morph";
                            #binding-cells = <0>;
                            bindings = <{base_bindings}>, <{morph_bindings}>;
                            mods = <{mods.group}>;
                        }};
                    }};
                }};
                """,
                dedent=True,
            )


def build_transform(filename: str, *, layout: Layout | None = None) -> None:
    """Generate devicetree code for the transformation"""
    if not layout:
        main_layers.analyze()
    file_out = Path(filename)
    with file_out.open("w") as out:
        writer = Writer(out)
        write_header_comment(filename, writer)
        (layout or main_layout).render_transform(writer)


def build_keymap(name: str) -> None:
    """Generate devicetree code for the keymap"""
    main_layers.analyze()
    file_out = Path(name)
    with file_out.open("w") as out:
        writer = Writer(out)
        write_header_comment(name, writer)

        preamble = f"{ccode!s}\n{devicetree!s}".strip()
        if preamble:
            writer.ln(preamble)

        layer.render_layer_defs(writer)
        build_macros(writer)
        build_morphs(writer)
        build_tap_dances(writer)
        build_rotary_encoders(writer)
        layout.render_keymap(writer)


def build_layout_json(
    filename: str | None = None,
    *,
    name: str | None = None,
    layer: Layer | None = None,
    layout: Layout | None = None,
) -> None:
    """Generate json code the layout"""
    if not layer or not layout:
        main_layers.analyze()
    if not name:
        name = (layout or main_layout).name
    file_out = Path(filename)
    with file_out.open("w") as out:
        writer = Writer(out)
        if not layer:
            _, def_layer = first(main_layers.data)
        else:
            def_layer = layer
        if not layout:
            layout = main_layout
        cells = zip(layout.cells(), def_layer.tokens, strict=False)
        name_key = name if name.startswith("LAYOUT") else f"LAYOUT_{name}"
        data = {
            "layouts": {
                name_key: {
                    "layout": [
                        cell.cell(token.label) for (cell, token) in cells
                    ]
                }
            }
        }
        writer(json.dumps(data, indent=2))


@dataclass
class SvgBlock:
    code: str = ""
    left: float = 0
    top: float = 0
    right: float = 0
    bottom: float = 0

    def append(self, block: SvgBlock) -> SvgBlock:
        self.code += f"\n{block.code}"
        self.left = min(self.left, block.left)
        self.top = min(self.top, block.top)
        self.right = max(self.right, block.right)
        self.bottom = max(self.bottom, block.bottom)
        return self

    @property
    def width(self) -> float:
        return self.right - self.left

    @property
    def height(self) -> float:
        return self.bottom - self.top

    def translated(self, x: float, y: float) -> SvgBlock:
        return SvgBlock(
            f"""<g transform="translate({x}, {y})">{self.code}</g>""",
            self.left + x,
            self.top + y,
            self.right + x,
            self.bottom + y,
        )


def build_layout_svg(
    filename: str | None = None,
    *,
    name: str | None = None,
    layer: Layer | None = None,
    layout: Layout | None = None,
) -> None:
    """Generate json code the layout"""
    if not layer or not layout:
        main_layers.analyze()

    if not name:
        name = (layout or main_layout).name

    if not layout:
        layout = main_layout

    margin = 10
    spacing = 40
    file_out = Path(filename)
    with file_out.open("w") as out:
        writer = Writer(out)
        if not layer:
            y = margin
            content = SvgBlock()
            for layer in main_layers.data.values():
                block = svg_layer(layer, layout)
                content.append(block.translated(margin, y))
                y += block.height + margin + spacing
            writer.ln(svg_content(name, content))
            return

        block = svg_layer(layer, layout)
        writer.ln(svg_content(name, block))


def svg_layer(layer: Layer, layout: Layout) -> SvgBlock:
    cells = zip(layout.cells(), layer.tokens, strict=False)
    keys = SvgBlock()
    keys.append(svg_text(f"Layer: {layer.name} ({layer.num})"))
    for cell, token in cells:
        key_block = svg_key(layer.name, cell.cell(token.svg_label))
        keys.append(key_block.translated(x=0, y=20))
    return keys


def svg_text(content: str, x: float = 0, y: float = 0, style: dict| None = None) -> SvgBlock:
    return SvgBlock(f"""
            <text x="{x}" y="{y}"
                style="{style_str(style or svg_key_text_style)}">
                <tspan
                    sodipodi:role="line"
                    x="{x}"
                    y="{y}"><![CDATA[{content}]]></tspan>
            </text>
    """)

def style_str(style: dict[str, str] | None):
    if style is None:
        return ""
    return ";".join(f"{k}:{v}" for (k, v) in style.items())


def svg_key(
    layer_name: str,
    cell: dict[str, Any],
    key_style: dict[str, str] | None = None,
    text_style: dict[str, Any] | None = None,
) -> SvgBlock:
    r = cell.get("r"), cell.get("rx"), cell.get("ry")
    rd = ",".join(str(i or 0) for i in r)
    rotate = f"rotate({rd})" if cell.get("r") else ""
    w, h = cell.get("w", 1), cell.get("h", 1)
    w, h = w * 19, h * 19
    x, y = cell.get("x", 0), cell.get("y", 0)
    x, y = x * 21, y * 21
    corner = w * 0.12
    label = cell.get("label", "")
    row, col = cell.get("matrix", (0, 0))
    tx = w / 2.0
    ty = h - (h - svg_key_font_size) / 2.0
    code = f"""
        <g transform="translate({x}, {y}) {rotate}" id="{layer_name}-{row}-{col}">
            <rect rx="{corner}" ry="{corner}"
                id="{layer_name}-{row}-{col}-key"
                width="{w}" height="{h}"
                style="{style_str(key_style or svg_key_style)}" />
            {svg_key_text(label, tx, ty, layer_name, row, col, text_style)}
        </g>
    """
    return SvgBlock(code, x, y, x + w, y + h)

def svg_key_text(label: str, tx: float, ty: float, layer_name: str, row: int, col: int, text_style: dict) -> str:
    spans = label.split()
    fs = svg_key_font_size
    lines = []
    ty = ty - (fs * (len(spans)-1) * 1.2)/2.0
    y = ty
    for i, txt in enumerate(spans):
        lines.append(f"""
            <tspan
                sodipodi:role="line"
                id="{layer_name}-{row}-{col}-tspan{i}"
                style="text-align:center;text-anchor:middle"
                x="{tx}"
                y="{y}"><![CDATA[{txt}]]></tspan>
                """)
        y += fs * 1.2
    content = "".join(lines)

    return f"""
        <text x="{tx}" y="{ty}"
            id="{layer_name}-{row}-{col}-text"
            style="{style_str(text_style or svg_key_text_style)}">
            {content}
        </text>
        """

svg_key_font_size = 5

svg_key_style = {
    "fill": "#e6e6e6",
    "stroke": "#b3b3b3",
    "stroke-width": "0.0989653",
    "stroke-dasharray": "none",
}

svg_key_text_style = {
    "font-size": f"{svg_key_font_size}px",
    "font-family": "Arial",
    "-inkscape-font-specification": "'Arial, Bold'",
    "text-align": "start",
    "writing-mode": "lr-tb",
    "direction": "ltr",
    "text-anchor": "start",
    "fill": "#000000",
    "stroke": "none",
}


def svg_content(name: str, body: SvgBlock) -> str:
    return f"""
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
    <svg
        width="{body.width * 1.02}mm"
        height="{body.height * 1.02}mm"
        viewBox="0 0 {body.width * 1.02} {body.height * 1.02}"
        version="1.1"
        id="svg1"
        inkscape:version="1.4 (e7c3feb100, 2024-10-09)"
        sodipodi:docname="{name}.svg"
        xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
        xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:svg="http://www.w3.org/2000/svg">
        <sodipodi:namedview
            id="namedview1"
            pagecolor="#ffffff"
            bordercolor="#000000"
            borderopacity="0.25"
            inkscape:showpageshadow="2"
            inkscape:pageopacity="0.0"
            inkscape:pagecheckerboard="0"
            inkscape:deskcolor="#d1d1d1"
            inkscape:document-units="mm"
            inkscape:current-layer="keys" />
        <defs
            id="defs1" />
        <g
            inkscape:label="boundaries"
            inkscape:groupmode="layer"
            id="boundaries">
            <rect id="draw-boundaries"
                x="{body.left}" y="{body.top}"
                width="{body.width * 1.02}" height="{body.height * 1.02}"
                style="fill:#ffffff;stroke:none;stroke-width=0.0;" />
        </g>
        <g
            inkscape:label="layouts"
            inkscape:groupmode="layer"
            id="layouts">
            {body.code}
        </g>
    </svg>
    """.strip()
