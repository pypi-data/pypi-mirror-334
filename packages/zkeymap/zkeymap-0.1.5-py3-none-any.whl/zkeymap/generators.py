# Copyright (c) 2025 Frank David Martínez Muñoz <mnesarco>
# SPDX-License-Identifier: MIT

"""
Output file generators.
"""

from __future__ import annotations

from dataclasses import dataclass
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Callable

from .model import (
    Layer,
    Layout,
    Writer,
    alias,
    ccode,
    devicetree,
    layer,
    layout,
)
from .model import layer as main_layers
from .model import layout as main_layout
from .utils import first


def init_writer(
    output: str | Writer, caller: Callable[[str | Writer], None]
) -> bool:
    """Open output file if required"""
    if isinstance(output, str):
        with Path(output).open("w") as out:
            writer = Writer(out)
            write_header_comment(output, writer)
            caller(writer)
        return False
    return True


def write_header_comment(name: str, writer: Writer) -> None:
    """Generate file header"""
    writer.ln(f"/* Generated by zkeymap: {datetime.now()} {name} */")


def build_macros(output: str | Writer) -> None:
    """Generate devicetree code of all defined macros."""
    if init_writer(output, build_macros):
        for macro in alias.macros:
            macro.render(output)


def build_tap_dances(output: str | Writer) -> None:
    """Generate devicetree code of all defined tap dances."""
    if init_writer(output, build_tap_dances):
        for dance in alias.tap_dances:
            dance.render(output)


def build_rotary_encoders(output: str | Writer) -> None:
    """Generate devicetree code of all defined rotary encoders."""
    if init_writer(output, build_rotary_encoders):
        for enc in alias.rot_encoders:
            enc.render(output)


def build_morphs(writer: Writer) -> None:
    """Generate devicetree code of all defined behavior-mod-morph"""
    for m in alias.morphs:
        if isinstance(m.normal, str):
            base_bindings = " ".join(m.resolve())
        else:
            base_bindings = f"&{m.normal.name}"
        for mods, morph in m.morph.items():
            morph_bindings = f"&{morph.name}"
            if morph.name.endswith("_ucu"):
                name = morph.name.removesuffix("_ucu")
            else:
                name = f"{morph.name}_{mods.key.lower()}"
            writer.ln(
                f"""
                / {{
                    behaviors {{
                        {name}: {name} {{
                            compatible = "zmk,behavior-mod-morph";
                            #binding-cells = <0>;
                            bindings = <{base_bindings}>, <{morph_bindings}>;
                            mods = <{mods.group}>;
                        }};
                    }};
                }};
                """,
                dedent=True,
            )


def build_transform(filename: str, *, layout: Layout | None = None) -> None:
    """Generate devicetree code for the transformation"""
    if not layout:
        main_layers.analyze()
    file_out = Path(filename)
    with file_out.open("w") as out:
        writer = Writer(out)
        write_header_comment(filename, writer)
        (layout or main_layout).render_transform(writer)


def build_keymap(name: str) -> None:
    """Generate devicetree code for the keymap"""
    main_layers.analyze()
    file_out = Path(name)
    with file_out.open("w") as out:
        writer = Writer(out)
        write_header_comment(name, writer)

        preamble = f"{ccode!s}\n{devicetree!s}".strip()
        if preamble:
            writer.ln(preamble)

        layer.render_layer_defs(writer)
        build_macros(writer)
        build_morphs(writer)
        build_tap_dances(writer)
        build_rotary_encoders(writer)
        layout.render_keymap(writer)


def build_layout_json(
    filename: str | None = None,
    *,
    name: str | None = None,
    layer: Layer | None = None,
    layout: Layout | None = None,
) -> None:
    """Generate json code the layout"""
    if not layer or not layout:
        main_layers.analyze()
    if not name:
        name = (layout or main_layout).name
    file_out = Path(filename)
    with file_out.open("w") as out:
        writer = Writer(out)
        if not layer:
            _, def_layer = first(main_layers.data)
        else:
            def_layer = layer
        if not layout:
            layout = main_layout
        cells = zip(layout.cells(), def_layer.tokens, strict=False)
        name_key = name if name.startswith("LAYOUT") else f"LAYOUT_{name}"
        data = {
            "layouts": {
                name_key: {
                    "layout": [
                        cell.cell(token.label) for (cell, token) in cells
                    ]
                }
            }
        }
        writer(json.dumps(data, indent=2))


@dataclass
class SvgBlock:
    code: str = ""
    left: float = 0
    top: float = 0
    right: float = 0
    bottom: float = 0

    def append(self, block: SvgBlock) -> SvgBlock:
        self.code += f"\n{block.code}"
        self.left = min(self.left, block.left)
        self.top = min(self.top, block.top)
        self.right = max(self.right, block.right)
        self.bottom = max(self.bottom, block.bottom)
        return self

    @property
    def width(self) -> float:
        return self.right - self.left

    @property
    def height(self) -> float:
        return self.bottom - self.top

    def translated(self, x: float, y: float) -> SvgBlock:
        return SvgBlock(
            f"""<g transform="translate({x}, {y})">{self.code}</g>""",
            self.left + x,
            self.top + y,
            self.right + x,
            self.bottom + y,
        )


def build_layout_svg(
    filename: str | None = None,
    *,
    name: str | None = None,
    layer: Layer | None = None,
    layout: Layout | None = None,
) -> None:
    """Generate json code the layout"""
    if not layer or not layout:
        main_layers.analyze()

    if not name:
        name = (layout or main_layout).name

    if not layout:
        layout = main_layout

    margin = 10
    spacing = 40
    file_out = Path(filename)
    with file_out.open("w") as out:
        writer = Writer(out)
        if not layer:
            y = margin
            content = SvgBlock()
            for layer in main_layers.data.values():
                block = svg_layer(layer, layout)
                content.append(block.translated(margin, y))
                y += block.height + margin + spacing
            writer.ln(svg_content(name, content))
            return

        block = svg_layer(layer, layout)
        writer.ln(svg_content(name, block))


def svg_layer(layer: Layer, layout: Layout) -> SvgBlock:
    cells = zip(layout.cells(), layer.tokens, strict=False)
    keys = SvgBlock()
    keys.append(svg_text(f"Layer: {layer.name} ({layer.num})"))
    for cell, token in cells:
        key_block = svg_key(layer.name, cell.cell(token.svg_label))
        keys.append(key_block.translated(x=0, y=20))
    return keys


def svg_text(
    content: str,
    x: float = 0,
    y: float = 0,
    style: dict | None = None,
) -> SvgBlock:
    return SvgBlock(f"""
            <text x="{x}" y="{y}"
                style="{style_str(style or svg_key_text_style)}">
                <tspan
                    sodipodi:role="line"
                    x="{x}"
                    y="{y}"><![CDATA[{content}]]></tspan>
            </text>
    """)


def style_str(style: dict[str, str] | None):
    if style is None:
        return ""
    return ";".join(f"{k}:{v}" for (k, v) in style.items())


def svg_key(
    layer_name: str,
    cell: dict[str, Any],
    key_style: dict[str, str] | None = None,
    text_style: dict[str, Any] | None = None,
) -> SvgBlock:
    r = cell.get("r"), cell.get("rx"), cell.get("ry")
    rd = ",".join(str(i or 0) for i in r)
    rotate = f"rotate({rd})" if cell.get("r") else ""
    w, h = cell.get("w", 1), cell.get("h", 1)
    w, h = w * 19, h * 19
    x, y = cell.get("x", 0), cell.get("y", 0)
    x, y = x * 21, y * 21
    corner = w * 0.12
    label = cell.get("label", "")
    row, col = cell.get("matrix", (0, 0))
    tx = w / 2.0
    ty = h - (h - svg_key_font_size) / 2.0
    code = f"""
        <g transform="translate({x}, {y}) {rotate}" id="{layer_name}-{row}-{col}">
            <rect rx="{corner}" ry="{corner}"
                id="{layer_name}-{row}-{col}-key"
                width="{w}" height="{h}"
                style="{style_str(key_style or svg_key_style)}" />
            {svg_key_text(label, tx, ty, layer_name, row, col, text_style)}
        </g>
    """
    return SvgBlock(code, x, y, x + w, y + h)


def svg_key_text(
    label: str,
    tx: float,
    ty: float,
    layer_name: str,
    row: int,
    col: int,
    text_style: dict,
) -> str:
    spans = label.split()
    fs = svg_key_font_size
    lines = []
    ty = ty - (fs * (len(spans) - 1) * 1.2) / 2.0
    y = ty
    for i, txt in enumerate(spans):
        lines.append(f"""
            <tspan
                sodipodi:role="line"
                id="{layer_name}-{row}-{col}-tspan{i}"
                style="text-align:center;text-anchor:middle"
                x="{tx}"
                y="{y}"><![CDATA[{txt}]]></tspan>
                """)
        y += fs * 1.2
    content = "".join(lines)

    return f"""
        <text x="{tx}" y="{ty}"
            id="{layer_name}-{row}-{col}-text"
            style="{style_str(text_style or svg_key_text_style)}">
            {content}
        </text>
        """


svg_key_font_size = 5

svg_key_style = {
    "fill": "#e6e6e6",
    "stroke": "#b3b3b3",
    "stroke-width": "0.0989653",
    "stroke-dasharray": "none",
}

svg_key_text_style = {
    "font-size": f"{svg_key_font_size}px",
    "font-family": "Arial",
    "-inkscape-font-specification": "'Arial, Bold'",
    "text-align": "start",
    "writing-mode": "lr-tb",
    "direction": "ltr",
    "text-anchor": "start",
    "fill": "#000000",
    "stroke": "none",
}


def svg_content(name: str, body: SvgBlock) -> str:
    return f"""
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
    <svg
        width="{body.width * 1.02}mm"
        height="{body.height * 1.02}mm"
        viewBox="0 0 {body.width * 1.02} {body.height * 1.02}"
        version="1.1"
        id="svg1"
        inkscape:version="1.4 (e7c3feb100, 2024-10-09)"
        sodipodi:docname="{name}.svg"
        xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
        xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:svg="http://www.w3.org/2000/svg">
        <sodipodi:namedview
            id="namedview1"
            pagecolor="#ffffff"
            bordercolor="#000000"
            borderopacity="0.25"
            inkscape:showpageshadow="2"
            inkscape:pageopacity="0.0"
            inkscape:pagecheckerboard="0"
            inkscape:deskcolor="#d1d1d1"
            inkscape:document-units="mm"
            inkscape:current-layer="keys" />
        <defs
            id="defs1" />
        <g
            inkscape:label="boundaries"
            inkscape:groupmode="layer"
            id="boundaries">
            <rect id="draw-boundaries"
                x="{body.left}" y="{body.top}"
                width="{body.width * 1.02}" height="{body.height * 1.02}"
                style="fill:#ffffff;stroke:none;stroke-width=0.0;" />
        </g>
        <g
            inkscape:label="layouts"
            inkscape:groupmode="layer"
            id="layouts">
            {body.code}
        </g>
    </svg>
    """.strip()


class _Namespace:
    def __init__(self, **kw):
        self.__dict__.update(kw)

    def __getattr__(self, name: str) -> str:
        return self.__dict__.get(name)


def build_layout_svg_drawer(
    *,
    svg_file: str,
    keymap_file: str,
    layout_json_file: str,
    config_file: str | None = None,
    layout: Layout | None = None,
) -> None:
    """
    Generate Svg Graphics using the external tool keymap_drawer if installed.

    This function calla an external library to render the SVG (keymap-drawer)
    So to make it work, the user needs to install it previously.

    ```
    pip install keymap-drawer
    ```
    """
    import sys

    try:
        from keymap_drawer import __main__ as kd, config as kd_config
    except ImportError:
        print("[ERROR] keymap_drawer is not installed.")
        sys.exit(-1)

    kmf = Path(keymap_file)
    if not kmf.exists():
        print(f"[ERROR] keymap file {keymap_file} not found")
        sys.exit(-2)

    lyf = Path(layout_json_file)
    if not lyf.exists():
        print(f"[ERROR] layout (json) file {layout_json_file} not found")
        sys.exit(-3)

    config = None
    if config_file:
        config = Path(config_file)
        if not config.exists():
            print(f"[ERROR] config file {config_file} not found")
            sys.exit(-4)

    import yaml

    if not layout:
        layout = main_layout

    svg_file: Path = Path(svg_file)
    yaml_file = svg_file.with_suffix(".yaml")

    # Generate the yaml file
    with kmf.open() as kmf_h:
        with yaml_file.open("w") as out:
            if config:
                with config.open() as config_h:
                    config_obj = kd_config.Config.parse_obj(
                        yaml.safe_load(config_h)
                    )
            else:
                config_obj = kd_config.Config()
            args = _Namespace(
                columns=layout.num_cols,
                zmk_keymap=kmf_h,
                output=out,
            )
            kd.parse(args, config_obj)

    if not yaml_file.exists():
        print(f"[ERROR] failed to parse keymap {keymap_file}")
        sys.exit(-5)

    # Generate svg file
    with yaml_file.open() as src:
        with svg_file.open("w") as out:
            args = _Namespace(
                keymap_yaml=src,
                qmk_info_json=str(lyf),
                output=out,
            )
            kd.draw(args, config_obj)
