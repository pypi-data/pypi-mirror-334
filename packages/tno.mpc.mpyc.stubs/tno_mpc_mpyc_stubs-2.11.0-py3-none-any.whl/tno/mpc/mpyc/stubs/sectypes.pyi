from __future__ import annotations

import sys
from asyncio import Future
from collections.abc import Sequence
from typing import TYPE_CHECKING, Any, Callable, ClassVar, Literal, overload

from mpyc.finfields import FiniteFieldArray, PrimeFieldElement
from mpyc.runtime import Runtime

if TYPE_CHECKING:
    import numpy as np
    from numpy.typing import NDArray

from tno.mpc.mpyc.stubs._sectypes import BaseSecureFloat

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self

runtime: Runtime

# SecureObject is actually defined in mpyc.asyncoro, but then we don't get the SecureObjectT to
# work in all places. Specifically, client libraries experience a conflict between
# mpyc.sectypes.SecureObject and tno.mpc.mpyc.stubs.asyncoro.SecureObject. As a workaround, we
# cheat and define Secureobject here.
class SecureObject:
    share: (
        PrimeFieldElement
        | Future[PrimeFieldElement]
        | tuple[SecureObject, SecureObject]
    )
    def __init__(self, value: Any | None = ...) -> None: ...
    def set_share(self, value: Any) -> None: ...

class SecureNumber(SecureObject):
    bit_length: ClassVar[int | None] = ...
    def __neg__(self) -> Self: ...
    def __pow__(self, other: int) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __add__(self, other: Self | float) -> Self: ...
    def __radd__(self, other: Self | float) -> Self: ...
    def __sub__(self, other: Self | float) -> Self: ...
    def __rsub__(self, other: Self | float) -> Self: ...
    def __mul__(self, other: Self | float) -> Self: ...
    def __rmul__(self, other: Self | float) -> Self: ...
    def __truediv__(self, other: Self | float) -> Self: ...
    def __rtruediv__(self, other: Self | float) -> Self: ...
    def __mod__(self, other: Self | int) -> Self: ...
    def __rmod__(self, other: Self | int) -> Self: ...
    def __floordiv__(self, other: Self | int) -> Self: ...
    def __rfloordiv__(self, other: Self | int) -> Self: ...
    def __divmod__(self, other: int) -> tuple[Self, Self]: ...
    def __rdivmod__(self, other: int) -> tuple[Self, Self]: ...
    def __lshift__(self, other: int) -> Self: ...
    def __rlshift__(self, other: int) -> Self: ...
    def __rshift__(self, other: int) -> Self: ...
    def __rrshift__(self, other: int) -> Self: ...
    def __and__(self, other: Self | int) -> Self: ...
    def __rand__(self, other: Self | int) -> Self: ...
    def __xor__(self, other: Self | int) -> Self: ...
    def __rxor__(self, other: Self | int) -> Self: ...
    def __invert__(self) -> Self: ...
    def __or__(self, other: Self | int) -> Self: ...
    def __ror__(self, other: Self | int) -> Self: ...
    def __lt__(self, other: Self | PrimeFieldElement | float) -> Self: ...
    def __le__(self, other: Self | PrimeFieldElement | float) -> Self: ...
    def __eq__(self, other: Self | PrimeFieldElement | float) -> Self: ...  # type: ignore[override]
    def __ge__(self, other: Self | PrimeFieldElement | float) -> Self: ...
    def __gt__(self, other: Self | PrimeFieldElement | float) -> Self: ...
    def __ne__(self, other: Self | PrimeFieldElement | float) -> Self: ...  # type: ignore[override]
    @overload
    def if_else(self, x: Self, y: Self) -> Self: ...
    @overload
    def if_else(self, x: list[Self], y: list[Self]) -> list[Self]: ...

class SecureFiniteField(SecureNumber):
    frac_length: ClassVar[int | None] = ...
    field: type[PrimeFieldElement]
    array: Callable[
        [Sequence[int] | Sequence[PrimeFieldElement] | NDArray[np.generic]],
        SecureFiniteFieldArray,
    ]
    subfield: type

    _output_conversion: None
    def __init__(self, value: int | PrimeFieldElement | None = ...) -> None: ...

class SecureInteger(SecureNumber):
    frac_length: ClassVar[int] = ...
    field: type[PrimeFieldElement] = ...
    array: Callable[
        [Sequence[int] | Sequence[PrimeFieldElement] | NDArray[np.generic]],
        SecureIntegerArray,
    ]

    _output_conversion: ClassVar[Callable[[int | PrimeFieldElement], int]] = ...
    def __init__(self, value: int | PrimeFieldElement | None = ...) -> None: ...

class SecureFixedPoint(SecureNumber):
    """Base class for secure (secret-shared) fixed-point numbers."""

    integral: bool
    frac_length: ClassVar[int] = ...
    field: type[PrimeFieldElement] = ...
    array: Callable[
        [
            Sequence[int]
            | Sequence[float]
            | Sequence[PrimeFieldElement]
            | NDArray[np.generic]
        ],
        SecureFixedPointArray,
    ]

    @classmethod
    def _output_conversion(cls, a: int | PrimeFieldElement) -> float: ...
    def __init__(
        self,
        value: int | float | PrimeFieldElement | None = ...,
        integral: bool | None = ...,
    ) -> None: ...

def SecFld(
    order: int | None = ...,
    modulus: int | str | Any | None = ...,
    char: int | None = ...,
    ext_deg: int | None = ...,
    min_order: int | None = ...,
    signed: bool = ...,
) -> type[SecureFiniteField]: ...
def SecInt(
    l: int | None = ..., p: int | None = ..., n: int = ...
) -> type[SecureInteger]: ...
def SecFxp(
    l: int | None = ...,
    f: int | None = ...,
    p: int | None = ...,
    n: int = ...,
) -> type[SecureFixedPoint]: ...

class SecureFloat(BaseSecureFloat):
    significand_type: SecureObject | None = ...
    exponent_type: SecureObject | None = ...
    def __init__(self, value: int | float | None = ...) -> None: ...
    @classmethod
    def _input(cls, x: list[Self], senders: list[int]) -> list[list[Self]]: ...

def SecFlt(
    l: int | None = ..., s: int | None = ..., e: int | None = None
) -> SecureFloat: ...

class SecureArray(SecureObject):
    sectype: type
    def __init__(
        self,
        value: Future[Any] | FiniteFieldArray | None = None,
        shape: tuple[int] | None = None,
    ) -> None: ...
    def __bool__(self) -> bool: ...
    def __array_function__(self, func, types, args, kwargs): ...  # type: ignore
    def ndim(self) -> int: ...
    def size(self) -> int: ...
    def __neg__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __add__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __radd__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __sub__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __rsub__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __mul__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __rmul__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __truediv__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __rtruediv__(self, other: Self | SecureObject | int | NDArray[Any]) -> Self: ...
    def __pow__(self, other: int) -> Self: ...
    def __matmul__(self, other: Self) -> Self: ...
    def __rmatmul__(self, other: Self) -> Self: ...
    def __lt__(self, other: Self) -> Self: ...
    def __le__(self, other: Self) -> Self: ...
    def __eq__(self, other: Self) -> Self: ...  # type: ignore
    def __ge__(self, other: Self) -> Self: ...
    def __gt__(self, other: Self) -> Self: ...
    def __ne__(self, other: Self) -> Self: ...  # type: ignore
    def __iter__(self) -> Any: ...
    @property
    def T(self) -> Self: ...
    def flat(self) -> Self: ...
    def __len__(self) -> int: ...
    def __getitem__(self, i: int | slice) -> Self: ...
    def flatten(
        self, order: Literal["C"] | Literal["F"] | Literal["A"] | Literal["K"] = "C"
    ) -> Self: ...
    def tolist(self) -> list[Any]: ...
    def reshape(
        self,
        shape: int | tuple[int, ...],
        order: Literal["C"] | Literal["F"] | Literal["A"] | Literal["K"] = "C",
    ) -> Self: ...
    def copy(
        self, order: Literal["C"] | Literal["F"] | Literal["A"] | Literal["K"] = "C"
    ) -> Self: ...
    def transpose(self, axes: int | None = None) -> Self: ...
    def swapaxes(self, axis1: int, axis2: int) -> Self: ...
    def sum(
        self, axis: int | None = None, keepdims: bool = False, initial: int = 0
    ) -> Self: ...
    def sort(self, axis: int = -1, key: Any = None) -> Self: ...
    @overload
    def argmax(
        self,
        axis: None = None,
        key: Any = None,
        arg_unary: bool = False,
        arg_only: bool = True,
    ) -> SecureInteger: ...
    @overload
    def argmax(
        self,
        axis: int,
        key: Any = None,
        arg_unary: bool = False,
        arg_only: bool = True,
    ) -> Self: ...
    @overload
    def argmax(
        self,
        axis: int | None = None,
        key: Any = None,
        arg_unary: bool = False,
        arg_only: bool = True,
    ) -> Self | SecureInteger: ...

class SecureFiniteFieldArray(SecureArray):
    frac_length = 0

    def __init__(
        self, value: FiniteFieldArray | None = ..., shape: tuple[int] | None = ...
    ) -> None: ...

class SecureIntegerArray(SecureArray):
    frac_length = 0

    @classmethod
    def _output_conversion(cls, a: int | NDArray[Any]) -> NDArray[Any]: ...
    def __init__(
        self,
        value: NDArray[Any] | Future[Any] | None = ...,
        shape: tuple[int] | None = ...,
    ) -> None: ...

class SecureFixedPointArray(SecureArray):
    frac_length = 0

    @classmethod
    def _output_conversion(cls, a: NDArray[Any]) -> NDArray[Any]: ...
    def __init__(
        self,
        value: NDArray[Any] | Future[Any] | None = None,
        shape: tuple[int] | None = None,
    ) -> None: ...
