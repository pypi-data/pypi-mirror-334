# pylint: disable=missing-module-docstring,missing-class-docstring,missing-function-docstring,unused-argument,too-many-public-methods
from __future__ import annotations

import sys
from typing import TYPE_CHECKING, Any, Literal

if TYPE_CHECKING:
    import numpy as np
    from numpy.typing import DTypeLike, NDArray

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self

class FiniteFieldElement:
    value: int
    modulus: int
    order: int = ...
    characteristic: int = ...
    ext_deg: int = ...
    byte_length: int = ...
    is_signed: bool = ...
    array: type
    _mix_types: type | tuple[type, ...]

    def __init__(self, value: int) -> None: ...
    @classmethod
    def to_bytes(cls, x: list[int]) -> bytes: ...
    @classmethod
    def from_bytes(cls, data: bytes) -> list[int]: ...

    # TODO: add polynomials as possibility to other (requires stubs for polynomials)
    def __add__(self, other: Self | int) -> Self: ...
    def __radd__(self, other: Self | int) -> Self: ...
    def __iadd__(self, other: Self | int) -> Self: ...
    def __sub__(self, other: Self | int) -> Self: ...
    def __rsub__(self, other: Self | int) -> Self: ...
    def __isub__(self, other: Self | int) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __mul__(self, other: Self | int) -> Self: ...
    def __rmul__(self, other: Self | int) -> Self: ...
    def __imul__(self, other: Self | int) -> Self: ...
    def __truediv__(self, other: Self | int) -> Self: ...
    def __rtruediv__(self, other: Self | int) -> Self: ...
    def __itruediv__(self, other: Self | int) -> Self: ...
    def __pow__(self, other: int) -> Self: ...
    def reciprocal(self) -> Self: ...
    def __lshift__(self, other: int) -> Self: ...
    def __rlshift__(self, other: int) -> Self: ...
    def __ilshift__(self, other: int) -> Self: ...
    def __rshift__(self, other: int) -> Self: ...
    def __rrshift__(self, other: int) -> Self: ...
    def __irshift__(self, other: int) -> Self: ...
    def is_sqr(self) -> bool: ...
    def sqrt(self, INV: bool = ...) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __bool__(self) -> bool: ...

class PrimeFieldElement(FiniteFieldElement):
    value: int
    modulus: int
    is_signed: bool = ...
    nth: int = ...
    root: int = ...
    _mix_types = int

    @staticmethod
    def createGF(p: int, n: int, w: int) -> PrimeFieldElement: ...
    def __int__(self) -> int: ...
    def __abs__(self) -> int: ...
    def signed_(self) -> int: ...
    def unsigned_(self) -> int: ...
    def __repr__(self) -> str: ...

class FiniteFieldArray:
    value: NDArray[np.object_]
    field: type
    _mix_types: type

    def shape(self) -> tuple[int]: ...
    def ndim(self) -> int: ...
    def size(self) -> int: ...
    def flat(self) -> NDArray[Any]: ...

    # Python Dunders
    def __len__(self) -> int: ...
    def __contains__(self, value: Any) -> bool: ...
    def __getitem__(self, key: int | tuple[int, ...]) -> Self: ...
    def __setitem__(self, key: int | tuple[int, ...], value: Self) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

    # Arithmetic Operations
    def __add__(self, other: Any) -> Self: ...
    def __radd__(self, other: Any) -> Self: ...
    def __iadd__(self, other: Any) -> Self: ...
    def __sub__(self, other: Any) -> Self: ...
    def __rsub__(self, other: Any) -> Self: ...
    def __isub__(self, other: Any) -> Self: ...
    def __mul__(self, other: Any) -> Self: ...
    def __rmul__(self, other: Any) -> Self: ...
    def __imul__(self, other: Any) -> Self: ...
    def __matmul__(self, other: Any) -> Self: ...
    def __rmatmul__(self, other: Any) -> Self: ...
    def __imatmul__(self, other: Any) -> Self: ...
    def __pow__(self, other: int | np.int8) -> Self: ...
    def __ipow__(self, other: int | np.int8) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __truediv__(self, other: Any) -> Self: ...
    def __rtruediv__(self, other: Any) -> Self: ...
    def __itruediv__(self, other: Any) -> Self: ...
    def __lshift__(self, other: int | np.int_) -> Self: ...
    def __ilshift__(self, other: int | np.int_) -> Self: ...
    def __rshift__(self, other: int | np.int_) -> Self: ...
    def __irshift__(self, other: int | np.int_) -> Self: ...

    # Almost Numpy Functions
    def reciprocal(self) -> Self: ...
    def sqrt(self, INV: bool = ...) -> Self: ...
    def is_sqrt(self) -> bool: ...

    # Numpy Functions
    def reshape(
        self,
        shape: int | tuple[int, ...] | None = None,
        order: Literal["C"] | Literal["F"] | Literal["A"] = "C",
        copy: bool | None = None,
    ) -> Self: ...
    def copy(self, *args: Any, **kwargs: Any) -> Self: ...
    def compress(
        self,
        condition: NDArray[np.bool_],
        axis: int | None = None,
        out: NDArray[Any] | None = None,
    ) -> Self: ...
    def nonzero(self) -> tuple[Self, ...]: ...
    def flatten(
        self, order: Literal["C"] | Literal["F"] | Literal["A"] | Literal["K"] = "C"
    ) -> Self: ...
    def take(
        self,
        indices: NDArray[Any],
        axis: int | None = None,
        out: NDArray[Any] | None = None,
        mode: Literal["raise"] | Literal["wrap"] | Literal["clip"] | None = None,
    ) -> Self: ...
    def tolist(self) -> list[Any]: ...
    def ravel(
        self,
        order: Literal["C"] | Literal["F"] | Literal["A"] | Literal["K"] = "C",
    ) -> Self: ...
    def repeat(
        self, repeats: int | list[int] | NDArray[np.int_], axis: int | None = None
    ) -> Self: ...
    def diagonal(self, offset: int = 0, axis1: int = 0, axis2: int = 1) -> Self: ...
    def sum(
        self,
        axis: int | tuple[int, ...] | None = None,
        dtype: DTypeLike | None = None,
        out: NDArray[Any] | None = None,
        keepdims: bool | None = None,
        initial: int | None = None,
        where: list[bool] | NDArray[np.bool_] | None = None,
    ) -> Self: ...
    def prod(
        self,
        axis: int | tuple[int, ...] | None = None,
        dtype: DTypeLike = None,
        out: NDArray[Any] | None = None,
        keepdims: bool | None = None,
        initial: int | None = None,
        where: list[bool] | NDArray[np.bool_] | None = None,
    ) -> Self: ...
    def trace(
        self,
        offset: int = 0,
        axis1: int = 0,
        axis2: int = 1,
        dtype: DTypeLike | None = None,
        out: NDArray[Any] | None = None,
    ) -> Self: ...
    def transpose(self, axes: list[int] | tuple[int, ...] | None = None) -> Self: ...
    def swapaxes(self, axis1: int, axis2: int) -> Self: ...
    @property
    def T(self) -> Self: ...
