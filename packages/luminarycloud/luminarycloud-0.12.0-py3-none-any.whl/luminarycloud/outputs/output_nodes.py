# Copyright 2025 Luminary Cloud, Inc. All Rights Reserved.

from .._client import get_default_client
from .._proto.api.v0.luminarycloud.output_node import output_node_pb2 as outnodepb
from .._proto.frontend.output import output_pb2 as feoutputpb
from .._proto.output import output_pb2 as outputpb
from dataclasses import dataclass, field
from ..types import Vector3
from typing import cast
from ..enum import (
    CalculationType,
    OutputNodeIncludes,
    QuantityType,
    ResidualType,
    SpaceAveragingType,
    Vector3Component,
    VolumeReductionType,
)


# CalculationType enum comes from the simulation protobuf, but that's just a copy-paste of the
# CalculationType enum in the frontend output protobuf. The OutputNode proto needs the frontend
# output proto type, so this helps us appease the type checker with a type cast.
def _proto_calc_type(calc_type: CalculationType) -> feoutputpb.CalculationType.ValueType:
    return cast(feoutputpb.CalculationType.ValueType, calc_type)


# TODO: make a simpler way to create Derived nodes, like from a string expression


@dataclass
class TrailingAverageConfig:
    """Configuration for a trailing average calculation of an OutputNode."""

    averaging_iterations: int = 0
    "Number of trailing iterations to average over."


@dataclass
class ConvergenceMonitoringConfig:
    """Configuration for a convergence monitoring calculation of an OutputNode."""

    averaging_iterations: int = 0
    "Number of trailing iterations to average over."
    iterations_to_consider: int = 0
    "Number of iterations to consider for convergence analysis."


@dataclass
class OutputNodeInclusions:
    """Specifies which values should be calculated for an OutputNode."""

    base_value: bool = True
    "Whether to include the base value, i.e. the quantity itself."
    coefficient: bool = False
    "Whether to compute the quantity coefficient. Only valid for forces and moments, ignored for other quantity types."
    trailing_average: TrailingAverageConfig | None = None
    "If present, computes a trailing average over the quantity."
    convergence_monitoring: ConvergenceMonitoringConfig | None = None
    "If present, computes a convergence monitoring criterion for the quantity."

    def _apply_to_proto(self, proto: feoutputpb.OutputNode) -> None:
        if self.base_value:
            proto.include[OutputNodeIncludes.BASE] = True
        if self.coefficient:
            proto.include[OutputNodeIncludes.COEFFICIENT] = True
        if self.trailing_average is not None:
            proto.trail_avg_iters = self.trailing_average.averaging_iterations
            if self.base_value:
                proto.include[OutputNodeIncludes.TIME_AVERAGE] = True
            if self.coefficient:
                proto.include[OutputNodeIncludes.COEFFICIENT_TIME_AVERAGE] = True
        if self.convergence_monitoring is not None:
            proto.average_iters = self.convergence_monitoring.averaging_iterations
            proto.analysis_iters = self.convergence_monitoring.iterations_to_consider
            proto.include[OutputNodeIncludes.MAX_DEV] = True

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "OutputNodeInclusions":
        instance = cls(
            base_value=proto.include[OutputNodeIncludes.BASE],
            coefficient=proto.include[OutputNodeIncludes.COEFFICIENT],
        )
        if proto.trail_avg_iters > 0 and (
            proto.include[OutputNodeIncludes.TIME_AVERAGE]
            or proto.include[OutputNodeIncludes.COEFFICIENT_TIME_AVERAGE]
        ):
            instance.trailing_average = TrailingAverageConfig(
                averaging_iterations=proto.trail_avg_iters,
            )
        if (
            proto.average_iters > 0
            and proto.analysis_iters > 0
            and proto.include[OutputNodeIncludes.MAX_DEV]
        ):
            instance.convergence_monitoring = ConvergenceMonitoringConfig(
                averaging_iterations=proto.average_iters,
                iterations_to_consider=proto.analysis_iters,
            )
        return instance


@dataclass
class SurfaceAverageOutputNode:
    """An output that is calculated as an average over surfaces."""

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."
    quantity: QuantityType = QuantityType.UNSPECIFIED
    "Type of quantity to measure."
    surfaces: list[str] = field(default_factory=list)
    "List of surfaces across which to calculate the output."
    out_surfaces: list[str] = field(default_factory=list)
    "For a `calc_type` of `CalculationType.DIFFERENCE`, a list of surfaces whose aggregate will be subtracted from the aggregate of the `surfaces` list."
    calc_type: CalculationType = CalculationType.AGGREGATE
    "Type of calculation to perform across all surfaces."
    reference_frame_id: str = ""
    "Reference frame to use for directional quantities. Empty string means use the global reference frame."
    include: OutputNodeInclusions = field(default_factory=OutputNodeInclusions)
    "Configuration for what values to include."
    space_averaging_type: SpaceAveragingType = SpaceAveragingType.AREA
    "Type of spatial averaging to use."
    vector_component: Vector3Component = Vector3Component.UNSPECIFIED
    "For vector quantities, the component to measure."

    def to_proto(self) -> feoutputpb.OutputNode:
        proto = feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            in_surfaces=self.surfaces,
            out_surfaces=self.out_surfaces,
            calc_type=_proto_calc_type(self.calc_type),
            frame_id=self.reference_frame_id,
            surface_average=feoutputpb.SurfaceAverageNode(
                quantity_type=self.quantity,
                vector_component=self.vector_component,
                props=outputpb.SurfaceAverageProperties(
                    averaging_type=self.space_averaging_type.value
                ),
            ),
        )
        self.include._apply_to_proto(proto)
        return proto

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "SurfaceAverageOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
            quantity=QuantityType(proto.surface_average.quantity_type),
            surfaces=list(proto.in_surfaces),
            out_surfaces=list(proto.out_surfaces),
            calc_type=CalculationType(proto.calc_type),
            reference_frame_id=proto.frame_id,
            include=OutputNodeInclusions.from_proto(proto),
            space_averaging_type=SpaceAveragingType(proto.surface_average.props.averaging_type),
            vector_component=Vector3Component(proto.surface_average.vector_component),
        )


@dataclass
class ForceOutputNode:
    """A force or moment output."""

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."
    quantity: QuantityType = QuantityType.UNSPECIFIED
    "Type of quantity to measure."
    surfaces: list[str] = field(default_factory=list)
    "List of surfaces across which to calculate the output."
    calc_type: CalculationType = CalculationType.AGGREGATE
    "Type of calculation to perform across all surfaces."
    reference_frame_id: str = ""
    "Reference frame to use for directional quantities. Empty string means use the global reference frame."
    include: OutputNodeInclusions = field(default_factory=OutputNodeInclusions)
    "Configuration for what values to include."
    force_direction: Vector3 = field(default_factory=Vector3)
    "Direction vector for force calculation."
    moment_center: Vector3 = field(default_factory=Vector3)
    "Center point for moment calculations."
    porous: bool = False
    "Whether the surfaces involved are porous."
    # TODO: it seems clumsy to make the user set `porous` correctly. we could probably set it
    # automatically based on the set of surfaces selected.

    def to_proto(self) -> feoutputpb.OutputNode:
        proto = feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            in_surfaces=self.surfaces,
            calc_type=_proto_calc_type(self.calc_type),
            frame_id=self.reference_frame_id,
            force=feoutputpb.ForceNode(
                quantity_type=self.quantity,
                props=outputpb.ForceProperties(
                    force_direction=self.force_direction._to_ad_proto(),
                    moment_center=self.moment_center._to_ad_proto(),
                    porous=self.porous,
                ),
            ),
        )
        self.include._apply_to_proto(proto)
        return proto

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "ForceOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
            quantity=QuantityType(proto.force.quantity_type),
            surfaces=list(proto.in_surfaces),
            calc_type=CalculationType(proto.calc_type),
            reference_frame_id=proto.frame_id,
            include=OutputNodeInclusions.from_proto(proto),
            force_direction=Vector3.from_ad_proto(proto.force.props.force_direction),
            moment_center=Vector3.from_ad_proto(proto.force.props.moment_center),
            porous=proto.force.props.porous,
        )


@dataclass
class ResidualOutputNode:
    """Configuration of simulation residuals."""

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."
    include: dict[QuantityType, bool] = field(default_factory=dict)
    "Which residuals to include."
    residual_type: ResidualType = ResidualType.RELATIVE
    "Type of residual calculation."
    physics_id: str = ""
    "Which physics these residuals apply to."

    def to_proto(self) -> feoutputpb.OutputNode:
        return feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            residual=feoutputpb.ResidualNode(
                props=outputpb.ResidualProperties(
                    type=self.residual_type.value,
                ),
                res_enabled={k: v for k, v in self.include.items()},
                physics_id=self.physics_id,
            ),
        )

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "ResidualOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
            include={QuantityType(k): v for k, v in proto.residual.res_enabled.items()},
            residual_type=ResidualType(proto.residual.props.type),
            physics_id=proto.residual.physics_id,
        )


@dataclass
class InnerIterationOutputNode:
    """The presence of this node enables reporting of inner iteration counts for transient simulations."""

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."

    def to_proto(self) -> feoutputpb.OutputNode:
        return feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            basic=feoutputpb.BasicNode(
                quantity_type=QuantityType.INNER_ITERATION_COUNT,
                props=outputpb.BasicType(),
            ),
        )

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "InnerIterationOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
        )


@dataclass
class PointProbeOutputNode:
    """An output that is calculated at specific points in the domain."""

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."
    quantity: QuantityType = QuantityType.UNSPECIFIED
    "Type of quantity to measure."
    points: list[str] = field(default_factory=list)
    "List of points for which to calculate the output."
    include: OutputNodeInclusions = field(default_factory=OutputNodeInclusions)
    "Configuration for what values to include."
    vector_component: Vector3Component = Vector3Component.UNSPECIFIED
    "For vector quantities, the component to measure."

    def to_proto(self) -> feoutputpb.OutputNode:
        proto = feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            in_surfaces=self.points,
            point_probe=feoutputpb.PointProbeNode(
                quantity_type=self.quantity,
                vector_component=self.vector_component,
                props=outputpb.PointProbeType(),
            ),
        )
        self.include._apply_to_proto(proto)
        return proto

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "PointProbeOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
            quantity=QuantityType(proto.point_probe.quantity_type),
            points=list(proto.in_surfaces),
            include=OutputNodeInclusions.from_proto(proto),
            vector_component=Vector3Component(proto.point_probe.vector_component),
        )


@dataclass
class VolumeReductionOutputNode:
    """An output that is calculated as an aggregation over volumes."""

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."
    quantity: QuantityType = QuantityType.UNSPECIFIED
    "Type of quantity to measure."
    volumes: list[str] = field(default_factory=list)
    "List of volumes across which to calculate the output."
    include: OutputNodeInclusions = field(default_factory=OutputNodeInclusions)
    "Configuration for what values to include."
    calc_type: CalculationType = CalculationType.AGGREGATE
    "Type of calculation to perform across all volumes."
    volume_reduction_type: VolumeReductionType = VolumeReductionType.AVERAGE
    "Type of reduction to perform for each volume."
    vector_component: Vector3Component = Vector3Component.UNSPECIFIED
    "For vector quantities, the component to measure."

    def to_proto(self) -> feoutputpb.OutputNode:
        proto = feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            in_surfaces=self.volumes,
            calc_type=_proto_calc_type(self.calc_type),
            volume_reduction=feoutputpb.VolumeReductionNode(
                quantity_type=self.quantity,
                vector_component=self.vector_component,
                props=outputpb.VolumeReductionProperties(
                    reduction_type=self.volume_reduction_type.value,
                ),
            ),
        )
        self.include._apply_to_proto(proto)
        return proto

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "VolumeReductionOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
            quantity=QuantityType(proto.volume_reduction.quantity_type),
            volumes=list(proto.in_surfaces),
            include=OutputNodeInclusions.from_proto(proto),
            calc_type=CalculationType(proto.calc_type),
            volume_reduction_type=VolumeReductionType(proto.volume_reduction.props.type),
            vector_component=Vector3Component(proto.volume_reduction.vector_component),
        )


@dataclass
class DerivedOutputNode:
    """An output that is expressed as a function of other output nodes."""

    @dataclass
    class ExpressionElement_Dependency:
        """A dependency on another output node."""

        id: str = ""
        "ID of the output node to depend on."
        include: OutputNodeIncludes = OutputNodeIncludes.BASE
        "Which particular OutputNode value to depend on."

        def to_proto(self) -> feoutputpb.ExpressionElement:
            return feoutputpb.ExpressionElement(
                dependency=feoutputpb.DerivedNodeDependency(
                    id=self.id,
                    include=self.include.value,
                )
            )

        @classmethod
        def from_proto(
            cls, proto: feoutputpb.ExpressionElement
        ) -> "DerivedOutputNode.ExpressionElement_Dependency":
            return cls(
                id=proto.dependency.id,
                include=OutputNodeIncludes(proto.dependency.include),
            )

    @dataclass
    class ExpressionElement_Substring:
        """A literal substring in the expression."""

        substring: str = ""
        "The substring"

        def to_proto(self) -> feoutputpb.ExpressionElement:
            return feoutputpb.ExpressionElement(
                substring=self.substring,
            )

        @classmethod
        def from_proto(
            cls, proto: feoutputpb.ExpressionElement
        ) -> "DerivedOutputNode.ExpressionElement_Substring":
            return cls(
                substring=proto.substring,
            )

    id: str = ""
    "Unique identifier for the node. Will be automatically generated by the server for new nodes."
    name: str = ""
    "Display name for the node."
    include: OutputNodeInclusions = field(default_factory=OutputNodeInclusions)
    "Configuration for what values to include."
    elements: list[ExpressionElement_Dependency | ExpressionElement_Substring] = field(
        default_factory=list
    )
    "Ordered list of expression elements."
    errors: list[str] = field(default_factory=list)
    "Validation errors"

    def to_proto(self) -> feoutputpb.OutputNode:
        proto = feoutputpb.OutputNode(
            id=self.id,
            name=self.name,
            derived=feoutputpb.DerivedNode(
                elements=[el.to_proto() for el in self.elements],
                errors=self.errors,
            ),
        )
        self.include._apply_to_proto(proto)
        return proto

    @classmethod
    def from_proto(cls, proto: feoutputpb.OutputNode) -> "DerivedOutputNode":
        return cls(
            id=proto.id,
            name=proto.name,
            include=OutputNodeInclusions.from_proto(proto),
            elements=[
                (
                    DerivedOutputNode.ExpressionElement_Dependency.from_proto(el)
                    if el.dependency
                    else DerivedOutputNode.ExpressionElement_Substring.from_proto(el)
                )
                for el in proto.derived.elements
            ],
            errors=list(proto.derived.errors),
        )


AnyOutputNodeType = (
    SurfaceAverageOutputNode
    | ForceOutputNode
    | ResidualOutputNode
    | InnerIterationOutputNode
    | PointProbeOutputNode
    | VolumeReductionOutputNode
    | DerivedOutputNode
)


def _specific_output_node_type_from_proto(proto: feoutputpb.OutputNode) -> AnyOutputNodeType:
    if proto.HasField("surface_average"):
        return SurfaceAverageOutputNode.from_proto(proto)
    elif proto.HasField("force"):
        return ForceOutputNode.from_proto(proto)
    elif proto.HasField("residual"):
        return ResidualOutputNode.from_proto(proto)
    elif (
        proto.HasField("basic") and proto.basic.quantity_type == QuantityType.INNER_ITERATION_COUNT
    ):
        return InnerIterationOutputNode.from_proto(proto)
    elif proto.HasField("point_probe"):
        return PointProbeOutputNode.from_proto(proto)
    elif proto.HasField("derived"):
        return DerivedOutputNode.from_proto(proto)
    elif proto.HasField("volume_reduction"):
        return VolumeReductionOutputNode.from_proto(proto)
    else:
        raise ValueError(f"Un-mappable output node: {proto}")


def create_output_node(
    project_id: str,
    output_node: AnyOutputNodeType,
) -> AnyOutputNodeType:
    """
    Create an output node for a project.

    Parameters
    ----------
    project_id : str
        Project in which to create the output node.
    output_node : AnyOutputNodeType
        Output node to create.
    """

    req = outnodepb.CreateOutputNodeRequest(
        output_node=output_node.to_proto(),
        project_id=project_id,
    )
    res = get_default_client().CreateOutputNode(req)
    return _specific_output_node_type_from_proto(res.output_node)


def get_output_node(
    project_id: str,
    id: str,
) -> AnyOutputNodeType:
    """
    Get an output node by ID.

    Parameters
    ----------
    project_id : str
        ID of the project that owns the output node.
    id : str
        ID of the output node to retrieve.
    """
    req = outnodepb.GetOutputNodeRequest(id=id, project_id=project_id)
    res = get_default_client().GetOutputNode(req)
    return _specific_output_node_type_from_proto(res.output_node)


def list_output_nodes(project_id: str) -> list[AnyOutputNodeType]:
    """
    List output nodes for a project.

    Parameters
    ----------
    project_id : str
        ID of the project to list output nodes for.
    """
    req = outnodepb.ListOutputNodesRequest(project_id=project_id)
    res = get_default_client().ListOutputNodes(req)
    return [_specific_output_node_type_from_proto(od) for od in res.output_nodes]


def update_output_node(
    project_id: str,
    output_node: AnyOutputNodeType,
) -> AnyOutputNodeType:
    """
    Update an output node.

    Parameters
    ----------
    project_id : str
        ID of the project that owns the output node.
    output_node : AnyOutputNodeType
        Updated output node. The ID of this output node must be present in the set of output nodes
        owned by the specified project.
    """

    req = outnodepb.UpdateOutputNodeRequest(
        output_node=output_node.to_proto(),
        project_id=project_id,
    )
    res = get_default_client().UpdateOutputNode(req)
    return _specific_output_node_type_from_proto(res.output_node)


def delete_output_node(project_id: str, id: str) -> None:
    """
    Delete an output node.

    Parameters
    ----------
    project_id : str
        ID of the project that owns the output node.
    id : str
        ID of the output node to delete.
    """
    req = outnodepb.DeleteOutputNodeRequest(id=id, project_id=project_id)
    get_default_client().DeleteOutputNode(req)
