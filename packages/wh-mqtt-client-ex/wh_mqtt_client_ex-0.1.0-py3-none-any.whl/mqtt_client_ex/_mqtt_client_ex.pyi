import abc
import logging
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from functools import partial as partial
from paho.mqtt.packettypes import PacketTypes as PacketTypes
from paho.mqtt.reasoncodes import ReasonCode as ReasonCode
from typing import Any, Callable

online_topic: str
offline_topic: str

def generate_mqtt_reply_id(): ...

class MqttClientEx(ABC, metaclass=abc.ABCMeta):
    host: Incomplete
    port: Incomplete
    client_id: Incomplete
    username: Incomplete
    password: Incomplete
    mqtt_client: Incomplete
    is_connected: bool
    is_loop_start: bool
    reconnect_delay: int
    client_keep_alive_time: Incomplete
    rpc_callback_topic: Incomplete
    callback_map: Incomplete
    def __init__(self, host: str, port: int, client_id: str = '', rpc_callback_topic: str | None = None, username: Incomplete | None = None, password: Incomplete | None = None, keepalive_interval: int = 10, logger: logging.Logger = None) -> None: ...
    def connect(self) -> None: ...
    def disconnect(self) -> None: ...
    def publish(self, topic: str, data: str, qos: int = 0) -> bool: ...
    def rpc_publish(self, topic, payload, pub_callback: Incomplete | None = None, ret_callback: Incomplete | None = None) -> None: ...
    def connect_loop(self) -> None: ...
    def add_task(self, interval: float, callback: Callable[[], Any], task_id: str | None = None) -> None: ...
    def remove_task(self, task_id) -> None: ...
    @abstractmethod
    def on_connect(self, client, userdata, flags, rc): ...
    @abstractmethod
    def on_disconnect(self, client, userdata, msg): ...
    @abstractmethod
    def on_message(self, client, userdata, msg): ...
    @abstractmethod
    def on_error(self, client, userdata, msg): ...
    @abstractmethod
    def on_online(self, msg): ...
    @abstractmethod
    def on_offline(self, msg): ...
    def print_info(self, msg) -> None: ...
    def print_error(self, msg) -> None: ...
    def __del__(self) -> None: ...
